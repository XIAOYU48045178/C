[TOC]

# 计算机

32 位 和 64 位 计算机主要指的是计算机的处理器（CPU）处理数据的能力 即 一次性处理的数据的位宽 即 字节数

- 32 位计算机 计算机的处理器一次可以处理 32 位（4字节）的数据 32 位系统可以寻址的最大内存空间为 4GB 2^32 字节 对于 32 位操作系统程序运行时会为其分配 4G 的虚拟内存 3G 用户空间 + 1G 内核空间
- 64位计算机 计算机可以一次处理 64 位（8字节）的数据 64 位系统能够支持更大的内存 理论上可以达到 16GB 即 2^64 字节 实际上由于物理限制目前还远未达到这个水平 能够更好地处理大型数据集和复杂的应用程序 还能够提高某些类型的计算速度 尤其是在涉及大量数据处理的领域 如科学计算视频编辑和大型数据库操作等 64位系统也可能需要更多的内存和处理器资源来运行

## 1. 用户空间和内核空间

- **用户空间**：用户空间是用户进程运行的地方 包括程序代码、数据、堆、栈等 用户进程只能访问自己的用户空间不能直接访问内核空间
- **内核空间**：内核空间是操作系统内核运行的地方包括操作系统提供的各种系统调用、中断处理、设备驱动等 内核空间对用户进程是不可见的用户进程通过系统调用接口与内核进行交互

## 2. 虚拟内存与物理内存

- 虚拟内存是操作系统提供的一种内存抽象它并不等同于物理内存 
- 物理内存是计算机硬件中实际存在的内存芯片所提供的内存空间 而虚拟内存则是通过内存管理算法将物理内存和磁盘上的交换空间 swap space 结合起来 为用户进程提供一个更大的连续的地址空间



# Radix

对于整数 有四种表示方式 二进制 0 1 满 2 进 1 以 0b 或 0B 开头 十进制 0-9 满 10 进 1  八进制 0-7 满 8 进 1 以数字 0 开头 十六进制 0-9 A10-F15 A-F 不区分大小写 满 16 进 1 以 0x 或 0X 开头 0b1011 0234 0x23A 计算机中数据是以二进制进行存放的 常将二进制数据以十六进制表示

## 1. 进制转换

### 1.1 十进制转换为二进制、八进制、十六进制

十进制转二进制整数转换 除以 2 反向取余 直到商为 0 终止 7 / 2 = 3...1 3 / 2 = 1...1 1 / 2 = 0...1 反向取余 111 补齐 0000 0111

十进制转二进制小数转换 乘 2 取整 顺序输出 0.625 * 2 = 1.25...1 0.25 * 2 = 0.5...0 0.5 * 2 = 1.0...1 顺序输出 101 补齐 1010 0000



> 6 -> 0000 0110 -- **对于 R 进制来说每次对 R 取余会得到最低位 每次对 R 整除会得到其它数**
>
> ```c
> 6 % 2 = 0  6 / 2 = 3
> 3 % 2 = 1  3 / 2 = 1
> 1 % 2 = 1  1 / 2 = 0
> ```



### 1.2 二进制、八进制、十六进制转换为十进制

二进制转十进制 0b1011=1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3

二进制转换成八进制、十六进制 二进制数转换成十六进制 二进制数的四位是十六进制数的一位 0b110.011 补齐 0b0110.0110 转换 0x6.6

### 1.3 八进制、十六进制转换成二进制

八进制数转换成二进制 八进制数的一位是二进制数的三位 012.3 转换 0b001010.011 补齐 0b0000 1010.0110 0000

八进制与十六进制之间的转换 两者之间的转换可以借助二进制完成 十六进制转八进制  0x6.6 -> 0b0110.0110 -> 06.3



# IEEE 754 标准

浮点数遵循 IEEE 754 标准进行存储 规定了浮点数的存储格式: 符号 指数 尾数 和运算规则 这个标准定义了两种浮点数表示单精度和双精度 任何一个浮点数的二进制数可以写为 NUM = (-1) ^ S * 2 ^ E * M 其中 S 表示符号位 0 为正数 1 为负数 E 表示阶码 即 指数 M 表示有效数字 即 尾数 规定 M 的值是 1 <= M < 2 可以写成 1.…… 的形式 规定 M 在存储时舍去第一个 1 只存储小数点之后的数字 对于单精度 32位 浮点数 符号位 1 bit 指数位 8 bits 尾数位 23 bits 对于双精度 64位 浮点数 符号位 1 bit 指数位 11 bits 尾数位 52 bits

E 是一个无符号整数 计数中指数是可以为负所以规定在存入 E 时在它原本的值上加上偏移量 即范围中间值 在使用时减去偏移量 这样 E 就可以存储有符号数了 对于单精度 32位 浮点数 指数位 8 bits 取值范围为 0~255 即 2^8-1 偏移量为 127 即 2^(8-1)-1 对于双精度 64位 浮点数 指数位 11 bits 取值范围 0~2047 即 2^11-1 偏移量为 1023 即 2^(11-1)-1 

M 对于单精度 32位 浮点数 可以保存  23 位小数信息 加上舍去的 1 则可以用 23 位来表示 24 个有效的信息 对于双精度 64位 浮点数 可以保存  52 位小数信息 加上舍去的 1 则可以用 52 位来表示 53 个有效的信息

## 1. 单精度 为例

10 -> 2: 12.345 12 -> 1100 0.345 -> 01011…… 12.345 近似二进制 为 1100.01011…… 规范化 1.10001011……E3 加上偏移值指数为 3 + 127 = 130 二进制表示为 10000010 组合 0 10000010 10001011……   

2 -> 10: 0 10000010 10001011……  10000010 十进制表示为 130 减去偏移值指数为 130 - 127 = 3 即 10001011……E3 逆规范化 补 1 即 1.10001011……E3 即 1100.01011…… 十进制为  12.345…… 

## 2. 误差

计算机内存是有限的 浮点数的表示方式是有限的 因此可能会进行截断或舍入操作导致精度损失 有些十进制小数无法精确表示为二进制浮点数 导致在进行浮点数运算时可能出现舍入误差 进而导致预期的结果和实际的二进制浮点数表示的结果不相等 如 0.1 在二进制中是一个无限循环小数 

>  bool i = 8.1/3 == 2.7 ? 1 : 0; //-- i = 0



# 原码、反码、补码

原码、反码和补码是计算机中用于表示有符号整数的三种不同编码方式 二进制的最高位是符号位 0 表示正数 1 表示负数 原码无处理 反码 正数的反码与其原码相同 负数的反码是其原码除符号位外其余各位取反 补码是计算机中表示有符号整数的标准方式 正数的补码与其原码相同 负数的补码是其反码加 1 补码解决了原码在加减运算时需要判断符号位的问题使得加法和减法可以统一处理 补码表示还解决了 0 的表示问题避免了 +0 和 -0 的歧义 在补码表示中 +0 和 -0 都是 00000000 一个数取补码再取补码结果是其本身



# 字符编码表

字符编码表是一种代码说明表格它规定了字符在计算机中的存储方式 通过字符编码表计算机可以将字符转换为二进制数据也可以将二进制数据转换回字符

- ASCII 适用范围 英文及部分特殊符号 编码规则: 使用了一个字节的 7 位表示一个字符 最高位为 0 示例: 字符 'A' 的 ASCII 码为 65 二进制表示为 01000001
- ISO-8859-1 适用范围 拉丁语系字符 编码规则: 使用了一个字节的 8 位表示一个字符 涵盖了更多的字符
- GB2312 适用范围 简体中文 编码规则: 使用两个字节表示一个字符 包含 6000~7000 个中文和符号
- GBK 适用范围 简体中文 扩展了 GB2312 的字符集 编码规则: 同样使用两个字节表示一个字符 但字符集更加广泛 包含2万个中文和符号
- Unicode 兼容 ASCII 国际标准码表 适用范围 涵盖了世界上几乎所有的文字 Unicode 编码表为每种字符分配了一个唯一的编码从而避免了字符集之间的冲突
- UTF-8 适用范围 基于 Unicode 的变长字符编码 编码规则: UTF-8 码表使用了 1~4 个字节不等来表示一个字符 其中常用的英文字符使用 1 个字节表示 而中文等复杂字符则使用多个字节表示 UTF-8 码表具有更高的效率并且在网络传输中更加节省带宽



# C 语言 内存模型

内存被划分为几个不同的区域 每个区域有其特定的用途和生命周期

- BSS 段 **存储程序中未初始化的全局变量和静态变量** **在程序加载到内存并准备开始执行之前分配内存**  此时这些变量会被**自动初始化为零** **程序结束时释放内存** 生命周期整个程序 静态内存分配 在编译时就已经知道所占内存空间大小
- 数据段 又称 静态数据区 **存放已初始化的全局变量和静态变量** **加载到内存并准备开始执行之前赋予初始值 即使被 const 修饰也不是编译时常量 编译时常量是没有加载到内存时就已经确定 嵌入到程序里面** 同上
- 代码段 **方法区 常量池** 包含程序的执行代码 内存通常是只读的 防止程序在运行时修改其自身的指令
- 堆 动态内存分配 **空间最大** 程序在运行时可以通过 **malloc、calloc** 等函数从堆中分配内存 使用完毕后需要通过 **free** 函数释放  栈区的 指针 指向堆区 **使用前要判断其值是否为 NULL** 如果**没有释放内存程序结束后由操作系统释放** 释放未分配的内存 或 重复释放已分配的内存则可能导致程序崩溃 申请内存一定非空判断 **do while 是一种思路** 动态内存分配 在运行时才能决定所占内存空间大小
- 栈 **存放局部变量** 具有后进先出 LIFO 即 last in first out 的特性非常适合于实现函数调用的上下文切换 **在进入代码块并执行到 statement 时分配内存在离开代码块释放内存** **作用域代码块** 静态内存分配 在编译时就已经知道所占内存空间大小

  

>C 语言属于静态语言除了堆区以外申请内存的时候必须在编译时就确定大小 静态存储区在程序加载到内存并准备开始执行之前分配内存赋予初始值 程序结束时释放内存 生命周期整个程序 栈内存的分配是在运行时进行的 在进入代码块并执行到 statement 时分配内存在离开代码块释放内存 作用域代码块 但其大小和使用方式在编译时是可以预测的 堆内存的大小和使用方式在编译时是无法完全确定的它取决于程序运行时的动态需求 在实际编程中全局变量、静态变量通常存放在数据段或 BSS 段中 而函数的局部变量则存放在栈中 动态分配的内存如通过 malloc 分配的内存位于堆中 **堆区向上增长 堆区空间大速度慢有我们申请释放 栈区向下增长空间小速度快由操作系统申请释放**



## 1. 栈 堆 工作原理

栈的工作原理类似于数据结构中的栈 当 statement 一个局部变量或调用一个函数时相关的数据会被推入栈中 函数调用结束后栈会自动弹出这些数据 栈的大小通常有限制 例如在 Linux 系统中可以通过 ulimit -s 命令查看或设置栈的大小 过大的局部变量或数组可能会导致栈溢出

堆是由程序员负责管理的内存区域 分配堆内存时需要确保成功分配并在不再使用时释放否则可能会导致内存泄漏 频繁的内存分配和释放还可能导致内存碎片影响程序性能



# 内存泄漏 内存溢出

## 1. 内存泄漏

内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放造成系统内存的浪费 内存泄漏通常发生在程序持续运行过程中当不再使用的内存没有及时释放时就会产生泄漏 初期可能不会对程序产生明显影响但随着时间的推移未释放的内存不断累积最终会导致系统资源耗尽程序性能下降甚至崩溃

## 2. 内存溢出

内存溢出是指应用系统中存在无法回收的内存或使用的内存过多最终使得程序运行要用到的内存大于能提供的最大内存 程序在申请内存时所需的内存空间超过了系统所分配的内存空间使得程序无法正常运行 内存溢出通常发生在程序运行时当数据结构的大小超过预设限制或者递归调用栈过深时就会发生内存溢出



> 确保动态分配的内存被正确释放避免内存泄漏 避免在栈上分配过大的局部变量以防栈溢出 使用内存时检查分配是否成功避免空指针引用出现段错误访问无权限的内存 段错误编译时不报错运行时报错 释放内存后将指针设置为 NULL 防止野指针的出现



# 作用域

- 块作用域 Block SCOPE 块作用域决定了白变量在程序中的可见性 函数块 代码块 条件块 循环块 生命周期指变量在内存中存在时间段
- 文件作用域 File SCOPE 文件作用域是指在所有函数外部 statement 的变量 可以 static 关键字或不加存储类说明符 这些变量在整个文件内都是可见的但在其他文件中不可见 如果变量前加了 static 关键字仍然具有文件作用域 但链接性变为内部链接意味着它只能在 statement 它的文件内部被访问
- 函数作用域 Function SCOPE 函数块
- 函数原型作用域 Function Prototype SCOPE 在函数原型中 statement 的参数只在原型内部具有作用域 这意味着你不能在函数原型外部引用这些参数名 尽管在函数定义内部你可以使用相同的参数名 它们是新的作用域实例  然而这个作用域在 C 语言标准中并没有明确提及因为它主要是一个编译器的实现细节 并且通常对程序员是透明的
- 程序作用域 Program SCOPE 或 全局作用域 Global SCOPE
- 全局作用域是指在所有函数外部声明的变量 这些变量在整个程序中都是可见的 包括在所有的源文件中 它们可以 statement 在头文件或通过外部链接 statement 全局变量应该谨慎使用因为它们可以导致代码难以维护和调试
- 标签作用域 Label SCOPE 虽然这不是一个常见的术语 但在讨论 goto 语句时 标签 label 的作用域是相关的 goto 语句可以跳转到同一函数内用 : 标记的标签处 标签的作用域限于它们所在的函数



# KEYWORDS



> void char short int long float double signed unsigned enum struct union typedef sizeof
>
> if else switch case default for do while continue break goto
>
> auto static extern register
>
> return     
>
> const volatile    
>
> 1999.12.16 ISO 推出 C99 新增关键字 inline restrict _Bool _Complex _Imaginary
>
> 2011.12.8 ISO 发布 C11 新增关键字 _Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic



## 1. const

初始化后不能修改 一旦将一个值赋给一个用 const statement 的变量这个值在整个程序的运行期间都将保持不变  全局和静态 const 变量在程序的启动时在全局或静态数据段中分配内存 局部 const 变量在函数调用时在栈上分配内存 const 修饰的变量不容易随着程序的运行而改变 volatile 修饰的变量容易随着程序的运行而改变 volatile 和 const 组成 cv 特性

指针常量是指一个指针本身是常量 也就是说一旦指针被初始化后指针的地址不能再被修改但可以通过指针修改它所指向的内容
常量指针是指指针所指向的内容是常量 也就是说指针可以指向不同的地址但是无法通过该指针修改它所指向的内容

- 修饰变量 const int PI = 3.1415926; int const PI = 3.1415926;
- 修饰指针 int* const P = &i; **修饰指针本身即 P** 指针指向的地址不能改变但可以修改指针指向的值即 i 的值
- 修饰指针指向的值 const int* p = &I; **修饰指针指向的值 *p** 指针可以指向其他地址但是不能通过指针修改它所指向的值即 i 的值
- 同时修饰指针和指针指向的值 const int* const P = &I;  同时修饰指针和指向的值 既不能指向其他地址也不能修改指针指向的值
- 修饰函数参数 int constFunctionArgument(const int size) 参数在函数内部不会被修改可以增加函数的安全性
- 修饰函数返回值 const int* constReturn()  对于基本数据类型的返回值 const 修饰符通常没有太大的实际意义因为返回值通常是通过值传递的而不是通过引用或指针传递的 但对于指针或引用类型的返回值 const 修饰符可以确保返回的对象不会被修改即返回不能修改指针指向的值的指针


## 2. auto

在 C 语言中 auto 是一个存储类说明符 是自动存储类型 用于指定变量的存储期 auto 变量是局部的存储期是临时的 它们只在定义它们代码块内有效一旦代码块被退出 auto 变量就会被销毁 它们存储在栈内存中当程序执行到代码块内它的定义处时 auto 变量会被创建 即 编译器为它分配栈内存 当退出代码块时 auto 变量会被销毁 即 释放栈内存 在 C 语言中 如果你在函数内部定义一个变量而没有指定存储类说明符 那么这个变量默认就是 auto 存储类的 因此 auto 关键字在大多数情况下是可以省略的 函数的外部定义的变量 即 全局变量 不能使用 auto 存储类型说明符

> ```c
> int main(int argc, const char *argv[]) {
>         for (int i = 0; i < 3; ++i) {
>             auto int k = 0; //-- k 每次进入代码块 重新 statement 初始化 出代码块销毁  
>             k += i; //-- k = 0 1 2
>         }
>         return 0;
> }
> ```

## 3. static

在 C 语言中 static 是一个存储类说明符 是静态存储类型 具有**内部链接性** 是一个存储类说明符用于指定变量的存储期 static 变量是静态存储变量 如果想将代码块中此变量的值保存至下一次执行时 最容易想到的方法是定义为全局的变量 但定义一个全局变量有许多缺点最明显的缺点是破坏了此变量的访问范围 使得在此代码块中定义的变量不仅仅只受此代码块控制 static 关键字则可以很好的解决这个问题 static 变量**只会在其第一次进入作用域时被初始化 程序走出代码块时并没有被销毁而一直存在直到再次执行代码块** **有默认值**

### 3.1 静态局部变量

当 static 修饰局部变量时 它会改变局部变量的存储位置 将其从栈区 即 自动变量存储区 移动到全局数据区 即 静态存储区 这样做的结果是静态局部变量的生命周期被延长它会在程序的整个运行期间保持其值而不仅仅是在声明它的函数被调用期间 同时静态局部变量的作用域仍然保持不变 即 它只能在声明它的代码块内部被访问 静态局部变量的生命周期是整个程序的执行过程所以**当程序走出定义该静态局部变量的代码块时变量并没有被销毁而一直存在直到再次执行代码块 因此静态局部变量在程序执行声明该变量时被首次初始化以后不再进行初始化**

```c
int main(int argc, char *argv[]) {
    for (int i = 0; i < 3; ++i) {
        static int k = 0; //-- 首次初始化以后不再进行初始化
        k += i; //-- k = 0 1 3 无 static k = 0 1 2    
    }
    //-- k 的作用域在这里已经结束 但它的生命周期会持续到程序结束
    return 0;
}
```

### 3.2 静态全局变量

当 static 修饰全局变量时 全局变量会具有**内部链接性**会限制全局变量的作用域使其只能在声明它的源文件或编译单元内部被访问 这有助于封装数据防止不同模块之间的直接依赖

### 3.3 静态函数

当 static 修饰函数时 函数会具有**内部链接性**它会限制函数的作用域 使其只能在声明它的源文件或编译单元内部被调用 这有助于隐藏实现细节减少命名冲突 并提高程序的模块化程度 非静态函数 即 默认情况下定义的函数 具有外部链接性 external linkage 这意味着它们可以在程序的其他部分甚至是在其他编译单元或源文件中 被引用和调用 静态函数则具有内部链接性 internal linkage 也称为文件作用域 file scope 这意味着**静态函数只能在声明它的源文件内部被调用其他源文件无法看到或调用这个函数即使它们包含了相同的头文件**

> ```c
> extern void static_function();
> extern void call_static_function();
> int main(int argc, char *argv[]) {
>         static_function(); //-- 无法调用 static 函数 内部链接性
>         call_static_function();
>         return 0;
> } //-- 1.c
> ```
>
> ```c
> static void static_function() {
>         puts("static function");
> }
> 
> void call_static_function() {
>         static_function();
> } //-- 2.c
> ```

## 4. extern

在 C 语言中 extern 是一个存储类说明符 是外部存储类型 具有外部链接性 用于定义在其他文件中 statement 的全局变量或函数 提供一个全局变量或函数的引用 当使用 extern 关键字时不会为变量分配任何存储空间而只是指示编译器该变量在其他文件中定义

> ```c
> #include "global.h" //-- 包含全局变量的 statement 头文件 
> int main(int argc, char *argv[]) {
>         return_i();
>         return i; -- 在这里可以访问全局变量 i
> } //-- 1.c
> ```
>
> ```c
> #ifndef _GLOBAL_H
> #define _GLOBAL_H
> 
> extern int i; //-- statement 全局变量 i 告诉编译器 i 是在其他地方定义的
> return_i();
>     
> #endif //-- global.h
> ```
>
> ```c
> #include <stdio.h>  
> #include "global.h" 
> 
> int i = 0; //-- 全局变量 i 的定义和初始化
> 
> int return_i() {  
>     return i;  
> } //-- 2.c
> ```

## 5. register

在 C 语言中 register 是一个存储类说明符 是寄存器存储类型 用于定义存储在寄存器中而不是随机存取存储器 RAM 中的局部变量 这意味着变量的最大尺寸等于寄存器的存储空间很小 不能对register 变量应用一元的 取地址运算符 '&' 因为寄存器的地址相对内存是独立的 register 存储类定义存储在寄存器所以变量的访问速度更快 寄存器只用于需要快速访问的变量 在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度 定义 register 并不意味着变量将被存储在寄存器中它意味着变量可能存储在寄存器中 他会向编译器提出一个请求 即 将某个变量存储在 CPU 的寄存器中 寄存器是 CPU 内部的一种快速存储单元 访问速度比内存快得多 然而需要注意的是 register 关键字只是向编译器提出一个建议或请求并不是强制性的编译器可能会忽略这个请求 因此如果编译器接受了这个请求那么使用这个变量进行的操作可能会执行得更快

忽略这个请求几种情况有很多  寄存器数量有限 现代 CPU 的寄存器数量是有限的 如果程序中使用了大量的 register 变量 编译器可能无法将它们全部存储在寄存器中  编译器优化 编译器可能会根据自己的优化策略来决定是否将变量存储在寄存器中 即使你使用了 register 关键字 编译器也可能出于优化考虑将其存储在内存中 变量地址需求 如果程序需要获取变量的地址 如通过指针操作那么编译器通常无法将其存储在寄存器中 变量类型某些类型的变量如结构体或大型数组可能无法存储在寄存器中



> 变量的存储类型有 自动存储类型 auto 静态存储类型 static 外部存储类型 extern 寄存器存储类型 register 四种 而函数的存储类型却只有 static 和 extern 两种 **函数的存储类型需求以及编译器和链接器的要求共同决定了这一点** 函数需要被其他文件或模块调用因此它们需要具有外部链接性 extern 或内部链接性 static 以控制其可见性和作用域 auto 关键字不提供这种链接性控制 它仅用于变量的类型推断或自动变量声明 使用 auto 作为函数的存储类型会破坏这些编译器和链接器的要求导致编译或链接错误



## 6. sizeof

在 C 语言中 sizeof 是一个操作符 确定**变量、对象、类型**所占的内存大小 以字节为单位 结果是一个编译时常量其值在编译时就已确定 **不可以运算位域的成员变量** 

**表达式的结果是在运行时才产生的 编译器根据运算符的优先级和类型转换规则来确定表达式的类型 进而确定类型所占内存大小 不会实际计算其操作数的值**

```c
int i = 3, j = 4;
int k = sizeof(++i + j++); //-- i = 3 j = 4 k = 4
```


## 7. 类型重定义关键字 _t 或 大写字母提醒是类型



# Gcc 编译器编译过程

1. 预处理 gcc -E 1.c -o 1.i
    - 将头文件复制粘贴过来
    - 将宏定义进行替换
    - 删除注释
2. 编译文件 将源文件转为汇编语言文件 gcc -S 1.i -o 1.s   gcc -S 1.c -o 1.s
3. 汇编 将汇编语言文件转为二进制机器码 gcc -c 1.s -o 1.o 简写 gcc -c 1.c
4. 链接文件 将 多个 .o 文件 和 库文件 链接在一起生成可执行二进制文件 gcc 1.c 2.c -o main.out gcc 1.o 2.o -o main.out

- 隐藏 warnin 警告 gcc 1.c -wall 显示 warnin 警告 gcc 1.c -w 
  
- 优化 O1 O2 O3  gcc -O2 1.c -o 1.out

- 生成可调式的程序 gcc -g 1.c -o 1.out 

  

# Gdb 调试工具

- 运行可调式程序 gdb 1.out

- run 运行可调式程序

- q 退出调试模式

- list 显示源文件 list 1 第一行开始展示

- break 1 第 1 行设置断点

- info b 查看断点

- clear 1 清除断点

- next 单步运行 一行

- print i 查看 i 变量值 可以直接看数组名 可以取地址

- continue 简写 c 跳转到下一个断点

- backtrac 简写 bt 查看堆栈 栈顶的函数为出错函数

  

# preprocessing

预处理器 CPP 不是编译器的组成部分 但它是编译过程中一个单独的步骤 预处理器命令以井号 # 开头 

预处理器的工作是逐行读取源代码并对遇到的每个预处理指令执行相应的操作 预处理后的代码也称为预处理输出 随后被传递给编译器进行实际的编译过程 预处理器不执行任何代码或进行任何计算 它只是进行文本替换和条件编译决策 因此预处理指令的错误如语法错误 通常会在编译阶段之前被检测到并生成相应的错误信息

预处理指令在代码管理和调试中非常有用 它们允许开发者在编译时添加额外的信息和控制编译器的行为 然而应该谨慎使用它们以避免在代码中引入过多的编译器特定依赖或使代码变得难以维护

## 1. 定义宏

宏是一段代码的别名它在编译时会被替换为实际的代码或值 宏定义通常放在文件的开头位于所有函数定义之前以确保它们在使用之前已经被定义 **宏替换是简单的文本替换**因此在使用宏时需要特别注意括号的使用以避免运算符优先级的问题 替换时不会进行类型检查因此使用时需要小心避免潜在的错误

### 1.1 预处理器运算符

- 宏延续运算符 backslash 宏通常写在一个单行上 但是如果宏太长一个单行容纳不下则使用宏延续运算符
- 字符串常量化运算符 # 当需要把一个宏的参数转换为字符串常量时则使用字符串常量化运算符
- 标记粘贴运算符 ## 允许在宏定义中两个独立的标记被合并为一个标记 

```c
#define PI 3.14159
#define MAX(n1, n2) ((n1) > (n2) ? (n2) : (n2)) //-- 3 * MAX(3, 3 + 4)
```

```c
#define SHOW printf("  *\n"); \
			 printf(" ***\n"); \
			 printf("*****\n");
```

### 1.2 宏 vs const  

宏定义的常量在编译时会被直接替换为其对应的 #define 定义的常量没有作用域限制它在定义之后的整个代码中都有效 而 const 定义的常量具有块级作用域 只在其定义所在的作用域内有效 宏常量的运算在预处理展开时就完成性能好 const 在运行时发生有一定性能开销 const 定义的常量会在符号表中有相应的条目有助于调试和可读性

### 1.3 宏 vs 类型重定义

类型重定义仅限于为类型定义符号名称 #define 不仅可以为类型定义别名也能为数值定义别名 比如您可以定义 1 为 ONE 类型重定义是由编译器执行解释的 #define 语句是由预编译器进行处理的 

## 2. 取消定义的宏 

```c
#define PI 3.14159
#undef PI
```

## 3. #include 文件包含 

告诉预处理器在实际编译之前包含另一个文件的内容 即 将所有内容被复制到中文件中 这个指令通常用于包含标准库头文件或项目中的其他源文件以便重用代码 #include <file> 在标准库路径目录中查找这些文件 目录是在设置环境时设置的 不在源文件目录去查找 用于包含系统提供的头文件 #include "file" 这种形式用于包含用户自定义的头文件 编译器首先会在当前文件的目录中查找这些文件 如果没有找到再按照编译器的配置查找其他路径 这些路径可能包括项目的其他目录标准库的安装目录或其他任何用户指定的目录

## 4. 条件编译

指令根据条件编译代码的不同部分这允许程序在不同的编译环境中以不同的方式编译 如根据不同的操作系统或编译器选项

- #if 如果给定条件为真则编译下面代码 #elif 如果前面的 #if 给定条件不为真并且当前条件为真则编译下面代码 #else 前面条件全为假则编译以下代码 #endif 结束这个条件编译块

- #ifdef 如果宏已经定义则返回真 #ifndef 如果宏没有定义则返回真  #endif 结束这个条件编译块

```c
#if 0
	注释
#endif
```

```C
#ifdef //-- CHINESE 在编译时 可以向 gcc 编译器传递 DDEBUG 开关量 可以在编译期间随时开启或关闭调试
   CHINESE
#elif
	ENGLISH
#endif
```

## 5. 行控制和错误处理

- #line 可以改变编译器报告的当前行号和文件名
- #error 生成编译时错误消息 停止编译 通常用于在编译时检查宏定义或条件如果条件不满足则生成错误
- #warning 生成编译时警告消息 不会停止编译 通常用于在编译时提供额外的信息或警告开发者注意可能的问题

```C
#line 100 "file.c" //-- 编译器将报告错误和警告为发生在 file.c 的第 100 行 file.c 如果省略则使用当前文件名
#ifndef PI
	#error "PI is not defined!"  
#endif
```

## 6. 真实项目中 .h 文件都写什么内容

- .结构体定义 宏定义 共用体定义
- 函数的引用声明
- 引用库提供的头文件
- 引用自己写的头文件

```c
#ifndef _MAIN_H
#define _MAIN_H

#endif
```

## 7. 预定义宏 

当前日期 以 "MM DD YYYY" 格式表示的字符常量 __DATE__ 

当前时间 以 "HH:MM:SS" 格式表示的字符常量 __TIME__ 

当前文件名包含路径 字符串常量 __FILE__ 

当前行号 十进制常量 __LINE__ 

当编译器以 ANSI 标准编译时 则定义为 1 __STDC__



# 分隔符 标识符  空格

分隔符  SEPARATORS 用于分隔语句和表达式常见的分隔符包括 逗号用于分隔变量声明或函数参数 分号是语句结束符也就是说每个语句必须以分号结束它表明一个逻辑实体的结束 括号 圆括号用于分组表达式函数调用 花括号 {} 用于定义代码块 方括号 [] 用于数组下标

标识符 Identifiers 是程序中变量、函数、数组等的名字 标识符由字母数字和下划线组成 必须是字母或下划线开头 大小写敏感 标识符内不允许出现标点字符如 @、$ 和 %

空格的行 被称为空白行 编译器会完全忽略它 空格用于描述空白符、制表符、换行符和注释 空格分隔语句的各个部分 让编译器能识别语句中的某个元素（比如 int）在哪里结束 下一个元素在哪里开始 为了增强可读性可以根据需要适当增加一些空格



# 主函数

## 1. 不标准的主函数

```c
int main() { //-- 不标准的主函数 有且只有一个 程序由主函数开始执行
	return 0; //-- 返回值通常是 0 表示正常执行
}
```

## 2. 标准的主函数

```c
int main(int argc, const char *argv[]) { //-- 标准的主函数
	return 0;
}
```

```c
int main(int argc, const char **argv) {
	return 0;
}
```

### 2.1 argc argument count 和 argv argument vector  

argc 和 argv 是主函数的形式参数 可以改变其名称 其类型是系统规定的不可改变 argc 是命令行全部参数的数量 包括程序的名称 无论是否命令行 argc >= 1  argv 是指向字符型指针数组的指针 每个字符串都是一个命令行参数 其中 argv[0] 存储的是含路径的程序名称 argv[1] 是指向第一个命令行参数的指针 依此类推 argv[argc] 是一个空指针用于标记数组的结束  

### 2.2 实际参数传递给主函数的 argc 和 argv 过程 

C 程序在编译和链接后会生成一个 exe 文件 执行该 exe 文件时可以直接执行也可以在命令行下带参数执行 命令行执行的形式为: 可执行文件名称 参数 1 参数 2 …… 可执行文件名称和参数参数之间均使用空格隔开 如果参数本身带有空格那么传递参数的时候应把参数放置在双引号 "" 或单引号 '' 内部 命令行字符串将作为实际参数传递给主函数 

## 3. char *argv[] vs char **argv

char *argv[] 字符指针数组 本质数组数组元素是指针指针指向一个个字符串

char **argv 字符二级指针 本质指针 指向第一个字符串

char *argv[] 这种形式更直观地表达了 argv 是一个字符指针数组 而使用 char **argv 则明确地指出它是一个指向首个字符串的指针 但在实际使用中它们是等价的



# constant

常量又叫做字面量是固定值 存在于常量池 在程序执行期间不会改变是**编译时常量** 如整数常量、浮点常量、字符常量、字符串字面量、枚举常量 常量定义后不能进行修改 常量可以直接在代码中使用

## 1. int constant

整型常量有 八进制整数以 0 作为前缀 十进制整数 十六进制整数以 0X 作为前缀  在 C 语言中直接书写二进制形式的整型常量不是标准的做法 以 0B 作为前缀 

整数常量也可以带一个后缀 U 表示无符号整数 L 表示长整数 可以是大写也可以是小写 可以单个出现也可以是其组合 顺序任意

## 2. float constant

浮点常量 在 C 语言中 浮点常量只有十进制数分为单精度实数和双精度实数 默认 double 类型 由整数部分、小数点、小数部分和指数部分组成 可以使用小数形式或者指数形式来表示浮点常量 合法 0.0 -0.25 .2 20. 3.0E5 3E5 -3.1E8 2.1L 2.1f 

## 3. 字符 constant

字符常量指以单引号括起来的单个个字符 以其 ASCII 码值来参与运算 转义字符 '\n' '\t' '\r' '\0'

## 4. string contant

字符串字面量括在双引号 " " 中 字符串常量在内存中以 null 终止符 '\0' 结尾



# variable

变量是程序可操作的存储区的名称 顾名思义其值是可以变化的 变量用于存储数据 每个变量在内存中都有自己特定的位置这个位置用于保存变量的当前值 变量三要素 数据类型 变量名 变量值 变量的名称可以由字母、数字和下划线字符组成 大小写敏感 必须以字母或下划线开头

可以多次 statement 同一个变量或函数 但只有第一次 statement 是有效的后续的 statement 只是重申了该变量或函数的存在性并不会产生新的存储空间 变量的定义是分配内存空间 可能设置初始值的过程 而声明只是告诉编译器变量的类型和名称 但不分配内存

## 1. statement

对于 extern statement 变量不会分配内存 内存已在其他文件定义的时候分配了 让指针指向 NULL 即不指向任何内存 可以控制何时以及是否通过 malloc 或其他动态内存分配函数来分配内存

## 2. 定义

定义会分配内存 变量采用先定义后使用的规则 说明符 变量或变量变量表达式列表 说明符包括 存储类型 变量基本类型的关键字 相同作用域变量名不能重复 未使用的变量 编译器通常会警告关于未使用的变量

## 3. 变量初始化

变量的初始化是在定义变量的同时为其赋予一个初始值 变量的初始化可以在定义时进行也可以在后续的代码中进行 初始化器由一个等号 后跟一个常量表达式组成 为了避免不确定的行为和错误建议在使用变量之前进行初始化

如果变量没有显式初始化那么它的默认值将取决于该变量的类型和其所在的作用域 对于全局变量和静态变量 整型变量默认值为 0 浮点型变量默认值为 0.0 字符型变量默认值为 '\0' 即 空字符 指针变量默认值为 NULL 表示指针不指向任何有效的内存地址 数组、结构体、联合等复合类型的变量它们的元素或成员将按照相应的规则进行默认初始化 局部变量在函数内部定义的非静态变量不会自动初始化为默认值它们的初始值是未定义的包含垃圾值 因此在使用局部变量之前应该显式地为其赋予一个初始值

## 4. 变量命名

变量的名称可以由字母、数字和下划线字符组成 大小写敏感 必须以字母或下划线开头

## 5. 变量生命周期 statement 定义 即 分配内存 初始化 访问 销毁

局部变量 定义在块级作用域里面的变量称为局部变量 如果不进行初始化默认值为随机数 生命周期仅限于该区域 存储在栈上动态分配并自动回收内存

全局变量 在所有函数外部定义整个程序都可见 生命周期贯穿程序运行始终 存储在数据段 静态分配内存 全局变量便于跨函数共享数据 但过度使用会降低代码可读性和可维护性且可能引发多线程并发访问问题 使用全局变量时需避免命名冲突防止意外覆盖或修改 同时在多线程环境中应特别小心考虑使用同步机制保护数据一致性

静态变量 从程序开始执行时创建到程序结束时销毁 静态变量的生命周期贯穿整个程序运行期间但其作用域可能受到限制

动态分配的变量 不进行初始化默认值为随机数 从分配内存时开始 到显式释放内存时结束 没释放则在程序结束由操作系统释放

寄存器变量 从代码块执行时创建到代码块执行完毕时销毁

常量 对于全局常量从程序开始执行时创建到程序结束时销毁 对于局部变量从代码块开始执行时创建代码块执行完毕时销毁 然而常量的值在程序运行期间是不可改变的



# 左值 和 右值

左值 lvalue 指向内存位置的表达式被称为左值表达式 左值可以出现在赋值号的左边或右边

右值 rvalue 指的是存储在内存中某些地址的数值 右值是不能对其进行赋值的表达式 也就是说右值可以出现在赋值号的右边但不能出现在赋值号的左边

变量是左值因此可以出现在赋值号的左边 数值型的字面值是右值因此不能被赋值 不能出现在赋值号的左边



# Data

- 基本数据类型: 整型 浮点型 字符型
- 构造类型: 数组 结构体 共用体
- 枚举类型
- 指针类型
- 空类型

### 9 x 9

```c
int main(){ 
	for(int i=1;i<=9;i++) {
		for(int j=1;j<=i;j++) { //-- 每次循环 j 不重新申请内存 只申请访问 赋值权限 j 生命周期长
			//-- 输出
        }
		//-- 换行
	}
	return 0;
}
```

### 鞍点鞍点的数为该数在该行最大在该列最小

```c
int main(){ 
    int arr[3][4] = { {1, 2, 6, 4}, {5, 6, 7, 8}, {9, 10, 11, 9} };

    for(int i = 0; i < 3; i++){
        int max = arr[i][0];
        int imax = 0;
        for(int j = 0; j < 4; j++){ //-- 每次 i 循环 j 重新申请内存 j 循环结束 j 生命周期结束销毁 速度慢  
            max = max > arr[i][j] max : arr[i][j];
            imax = max == arr[i][j] j : imax;
        }

        int min = arr[0][imax];
        for(int j = 0; j < 3; j++){
            if(min > arr[j][imax]){
                min=arr[j][imax];
            }
        }

        if(min == max){
            //-- max, i + 1, imax + 1
        }

    }

}
```





# Basic Data

程序设计中最小数据单元即原子数据类型 其他数据类型 结构体 共用体可以使用这些基本数据类型 不同计算机体系结构中类型所占的比特数可能是不同的 精度指的是能够准确表示的小数部分的位数  **范围 过了从头再来**

```c
int main(){
    int i = 5; int j = 5;
    for (i; ++i != 5 ; 0) { } //-- 延时 i = 5 int 有范围 过了从头再来
    for (j; j++ != 5 ; 0) { } //-- 不延时 j = 6
    return 0;    
}
```

## 1. 整型

- short int 2 字节 16 位 取值范围: 有符号 -2^15 ~ 2^15-1 无符号 0 ~ 2^16-1
- int 4 字节 32 位 取值范围: 有符号 -2^31 ~ 2^31-1 无符号 0 ~ 2^32-1 
- long int 32 位系统上通常是 4 字节 取值范围: 有符号 -2^31 ~ -2^31-1 无符号 0 ~ 2^32-1 在 64 位系统上通常是 8 字节 位取值范围: 有符号 -2^63 ~ -2^63-1 无符号 0 ~ 2^64-1
- long long C99 标准引入 8 字节 64 位 取值范围: 有符号 -2^63 ~ 2^63-1 无符号 0 ~ 2^64-1

  

> 整数拆分
>
> int i1 = 21, i2 = 321, i3 = 4321;
> i1 % 10; i1 / 10 % 10;
> i2 % 10; i2 / 10 % 10; i2 / 100 % 10;
> i3 % 10; i3 / 10 % 10; i3 / 100 % 10; i3 / 1000 % 10;



### 水仙花 100 ~ 999

```c
int narcissus(){ 
	int i = 100, i3 = 0, i2 = 0, i1 = 0;
	for(i; i <= 999; ++i){
		i3 = i / 100 % 10;
		i2 = i / 10 % 10;
		i1 = i % 10;
		if(i3 * i3 * i3 + i2 * i2 * i2 + i1 * i1 *i1 == i){
            //-- i
        }
	}	
    return 0;
}
```



## 2. 浮点型 

- float 4 字节 32 位 精度: 6 ~ 7 范围约为: 有符号 -3.4E-38 ~ 3.4E+38 存储: 1 位符号 8 位指数 23 位小数 float i = 2.1f
- double 8 字节 64 位 精度: 15 ~ 16 范围约为: 有符号 -1.7E-308 ~ 1.7E+308 存储: 1 位符号 11 位指数 52 位小数
- long double 16 字节 128 位 精度 18 ~ 19 

## 3. 字符型

- char 1 字节 8 位 取值范围: 有符号 -128 ~ 127 无符号 0 ~ 255 通常用 ASCII 表示 可以看作整型的一种 'A' = 97 - 32 '0' = 48  '5' - 48 = 5 '\0' = 0

  

> '0' <= c && c <= '9'
> 'A' <= c && c <= 'Z'
> 'a' <= c && c <= 'z'






# 类型转换

在赋值运算中赋值号两边量的数据类型不同时赋值号右边量的类型将转换为左边量的类型 如果右边量的数据类型长度比左边长时将丢失一部分数据 这样会降低精度

## 1. 隐式类型转换

- char -> int -> unsigned int
- short -> int -> unsigned int 
- int -> unsigned int -> long -> unsigned long -> long long -> unsigned long long -> float -> double -> long double

### 1.1 整数提升

当进行算术运算或位操作时较小的整数类型会自动提升为较大的整数类型

### 1.2 浮点转换

整数和浮点数进行运算时整数会被隐式转换为浮点数

## 2. 强制类型转换

显式类型转换需要程序员在代码中显式地指定转换的类型 这通常通过使用类型转换运算符 在进行类型转换时 应谨慎处理 以避免数据丢失或精度下降



# 精度丢失



> int i  = 1;  //-- i + j 2.11111116409301760000000000000000000000000000000000 7
> float j = 1.1111111111111111111f; 
>
> float i = 1.1111111111111111111f;  //-- i + j 3.22222227520412870000000000000000000000000000000000 7
> double j = 2.1111111111111111111;
>
> float i = 1.1111111111111111111f;  //-- i + j 3.22222232818603520000000000000000000000000000000000 6
> float j = 2.1111111111111111111f;
>
> double i = 1.1111111111111111111;  //-- i + j 3.22222222222222230000000000000000000000000000000000 15
> double j = 2.1111111111111111111;
>
> 100 - 'A' + 2.11111111111111111111111111111f  //-- 37.11111068725585900000000000000000000000000000000000 5
> 100 - 'A' + 2.11111111111111111111111111111 //-- 37.11111111111111400000000000000000000000000000000000 14



# 表达式

表达式是由操作数和运算符组成的序列




# 运算符

## 1. 算数运算符 加 减 乘 除 取余 自增 自减

- 整除 两个整数相除结果还是整数
- 取余 不能对小数进行运算 n1 % n2 = n1 - n1 / n2 * n2 
- 自增自减运算符 int n1 = 0 n1++ n1++ =  0 n1 = 1 int n1 = ++n2 n2 = n2 + 1 n1 = n2 前加加 先用后加

## 2. 关系运算符 > < == != <= >= 结果只有 0 1

## 3. 逻辑运算符 && || 短路

短路求值是指在逻辑表达式的求值过程中如果根据已经计算的部分表达式的值就能够确定整个表达式的结果那么剩余的部分将不再计算 

当使用 AND 运算符时如果左边的操作数为假那么右边的操作数就不会被计算 当使用 OR 运算符时如果左边的操作数为真那么右边的操作数就不会被计算

> int i1 = 0, i2 = 0;
> 0 & (i1 = 5); 1 && (i2 = 5); //-- i1 = 5 i2 = 0

## 4. 位运算符 & | ^ ~ << >>

- 算术左移 << 符号位不变 低位补 0 int i1 = 1<<2 00000001 -> 00000100 即 1 * 2 * 2 = 4 int i2 = -8<<2 -32
- 算术右移 >> 低位溢出 符号位不变 符号位填充即正数左边补 0 负数左边补 1 int i1 = 1>>2 1 -> 00000001 -> 00000000 即 1 / 2 / 2 = 0 int i2 = -8>>2 -2

### 4.1 C 语言 无 逻辑右移 左移

- 逻辑右移: 高位补 0 这种右移通常用于无符号整数 
- 逻辑左移: 逻辑左移和算术左移在效果上相同 因为它们在执行移位操作时遵循相同的规则: 将二进制数整体向左移动指定的位数同时在右边补 0

> 2 -> 0000 0010    1 -> 0000 0001    2&1 --> 0000 0010 & 0000 0001 = 0
> 4 -> 0000 0100    3 -> 0000 0011    4&3 --> 0000 0100 & 0000 0011 = 0

## 5. 赋值运算符 等 加等 减等 乘等 除等 取余等

> int i1 = 3 + 2; int i2 = i1;
> int i3 = 3 + 4, i4 = i3;

## 6. 三元运算符 运算结果为表达式 1 或 表达式 2 的表达式值

> int i1 = -10, i2 = -20, i3 = -30;
> int max = i1;
> max = max > i2 ? max : i2;
> max = max > i3 ? max : i3;

> int i1 = 2, i2 = 3, max = 0;
> i1 < i2 ? i1 : max; //-- 表达式值为 2
> i1 > i2 ? max = i1 : max = i2 //-- 0 = i2 错误

## 7. 逗号 最后一个是逗号表达式的结果

> int i1 = 20 - 2, 9 - 6 / 4, 8 / 2; //-- i1 = 18
> int i2 = (20 - 2, 9 - 6 / 4, 8 / 2); //-- i2 = 4

## 8. 解引用 地址访问运算符 * 给地址访问其值



# 运算符优先级

**运算符有不同的优先级 高优先级的运算符会在低优先级的运算符之前把两边操作数进行结合 相当于加括号 如果两个运算符的优先级相同那么看它是从左向右结合还是从右向左结合计算顺序仍然是从左到右**

**单目 算数 关系 位 逻辑 三目 赋值 逗号 只有单目运算符、三目运算符、赋值运算符是从右向左运算的**

点 括号 花括号 分号 单目运算符: ++ -- ~ sizeof 算数运算符: * / % 算数运算符: + - 位运算符: << >> >>> 比较运算符: < > <= >= 比较运算符: == != 位运算符: & 位运算符: ^ 位运算符: | 逻辑运算符: && 逻辑运算符: || 三元运算符: : 赋值运算符: = *= /= %= 复合赋值运算符: += -= <<= >>= 复合赋值运算符: >>>= &= ^= != 逗号

> int i = 1, j = 0, k = 0;
>
> i > 0 && !(j == 3) || k > 5 -- 1
>
> !(i + 1 > 0) && j == 0 || k > 0 -- 0
> i < 0 || j == 0 && k > 0 -- 0
> i += j == k, j = i + 2, k = i + j + i > 0 -- i = 2 j = 4 k = 1




> int i1 = 1, i2 = 4, i3 = 3, i4 = 2;
> i1 < i2 i1 : i3 < i4 i3 : i4;  //--可以看作 IF ELSE 实际 : 自右向左

> int i1 = 0, i2 = 0, i3 = 0, i4 = 0;
> (i1 = 1) || (i2 = 2) && (i3 = 3) || (i4 = 4); -- 1 0 0 0



# 交换变量值



> int i1 = 5, i2 = 10, i3 = 0; //-- 整数 浮点数 空间复杂度大 不会溢出
> i3 = i1; i1 = i2; i2 = i3;
>
> int i1 = 5, i2 = 10; //-- 整数 浮点数 有可能溢出
> i1 = i1 + i2; i2 = i1 - i2; i1 = i1 - i2;
>
> int i1 = 5, i2 = 10; //-- 整数
> i1 = i1 ^ i2; i2 = i1 ^ i2; i1 = i1 ^ i2;
>
> int i1 = 5, i2 = 10; //-- 浮点数
> i1 = i1 * i2; i2 = i1 / i2; i1 = i1 / i2;




# ProcessControl

## 1. IF

> if(){...}
>
> if(){...}else(){...}
>
> if(){...}else if(){...}
>
> if(){...}else if(){...}else{...}

```c
int main(int argc, const char *argv[]){
    int i = 2;
    if( 1 < i <3) //-- 1 < 2 1 1 < 3 1 
    return 0;
}
```

### 三角形两边之和大于第三边

```c
if(i1 + i2 + i3 - max - max > 0)
```

### 1.1 卫语句 Guard Clauses

在函数的开头就处理掉一些不符合预期的情况提前返回或异常处理避免进入后续的逻辑流程 将最可能失败或最常见的情况放在前面以便尽早地排除它们这样做可以提高代码的效率

```c
int isleapYear(int i) { -- if (i % 400 == 0 || (i % 4 == 0 && i % 100 != 0))
  	if(i % 400 == 0){
        return 1;
    }
    if(i % 100 == 0){
        return 0;
    }
    if(i % 4 == 0){
        return 1;
    }   	
    return 0;  
}
```

## 2. switch

> switch(变量表达式){ -- 不能浮点数
>     case 常量表达式 1:
>         ...
>         break; -- 无 break 穿透
>     case 常量表达式 2: -- 不能与前面相同否则报错
>         ...
>         break;
>     default: -- 无匹配项执行 如果前一个 case 无 break 则也执行
>         ...
>         break;
> }

## 3. 循环语句 while

```c
定义初始变量
while(表达式){
	改变初始变量值
}
```

### 计算最大公约数的函数欧几里得算法 计算最小公倍数的函数 

```c
int gcd(int i1, int i2) { 
	int i3 = 0
    while (i2 != 0) {  
        i3 = i2;  
        i2 = i1 % i2;  
        i1 = i3;  
    }  
    return i1;  
}  

int lcm(int i1, int i2, int gcd_value) {
    return (i1 / gcd_value) * i2;  
}
```

### 最大公约数 最小公倍数

```c
int gcd(int i1, int i2) { 
    int min = i1 < i2 i1 : i2;
    int i = 0;
    for(i = min; i > 1; i--){
        if(i1 % i == 0 && i2 % i == 0) break;
    }
    return i;  
}  
    
int lcm(int i1, int i2) {  
    int max = i1 > i2 i1 : i2;
    int i = 0;
    for(i = max; i <= i1 * i2; i++){
        if(i % i1 == 0 && i % i2 == 0) break;
    }
    return i;   
}
```

### 计数和逆序数

```c
int* cnt_rev(int i1){ 
    int cnt = 0, occas = i1;  
    while (occas != 0) {  
        occas /= 10;  
        ++cnt;  
    }  

    int digit = 0, rev = 0; occas = i1;  
    while (occas != 0) {  
        digit = occas % 10;  
        rev = rev * 10 + digit;
        occas /= 10;  
    }

    static int arr[2] = {};
    arr[0] = cnt;
    arr[1] = rev;

    return arr;
}   
```

## 4. do while

```c
定义初始变量
do{
	改变初始值
} while(表达式)
```

## 5. for

```c
for(定义初始变量; 条件判断; 改变初始值){ }
```



> 总结 我是什么 我要不要进入 我是 NULL 我要进入判断 那就 !NULL 我是 i 我要进入 那就 i          正常结束时不满足条件的第一个数退出循环



### Prime

```c
#include <stdbool.h>  
 
bool isPrime(int n) {
	if (n <= 1) return false;  
    if (n <= 3) return true;  

    if (n % 2 == 0 || n % 3 == 0) return false; //-- 排除偶数和 3 的倍数  

    for (int i = 5; i * i <= n; i += 6) { //-- 检查形如 6k ± 1 的数  
        if (n % i == 0 || n % (i + 2) == 0) return false;  
    }  
    return true;  

} 
```

```c
int isPrime(int i1){
	int i = 2;
	for(i; i <= i1 - 1; i++) //-- i1 - 1 + 1 循环结束
		if(i1 % i==0) break;
	if(i > i1 - 1) return 1;
	return 0;
}
```

### 打印金字塔

```c
int main() { 
    int row = 5;
    int i = 1; j = 1;
    int space = 0, star = 0;  
    for (i; i <= row; i++) {   
        space = row - i;  
        for (j = 1; j <= space; j++) {  
            //-- " " 
        }  
        star = 2 * i - 1;  
        for (j = 1; j <= star; j++) {  
            //-- "*" 
        }  
        //-- 换行  
    }  
    return 0;  
}
```

### factorial

```c
unsigned long long factorial(int num) { 
    unsigned long long result = 1;  
    for (int i = 1; i <= num; i++) {  
        result *= i;  
    }  
    return result;  
}
```



# Break Continue

## 1. break

break 关键字用于立即终止循环 并跳出循环体 当程序执行到 break语句时 循环将立即终止 不再执行循环体内未执行的语句 然后程序将继续执行循环后面的代码 break 通常用在循环体内遇到满足某个条件时需要提前终止循环的情况

## 2. continue

continue 关键字用于跳过当前循环的剩余代码 继续执行下一次循环 当程序执行到 continue 语句时 将直接跳到循环条件判断处 继续下一次循环的执行 continue 通常用在循环体内遇到某个条件需要跳过当前循环的剩余代码时

```c
int main(){
    int i = 0, sum = 0;
	while(i <= 100){
		if(i++ == 90){ //-- i++ = 90 i = 91 i++ =91 i = 92
			continue;
		}
		sum += i; //-- 此时 i = 92
	}
	//-- 5060 没加 91 加 101 了
    return 0;
}
```



# ARR

数组数据结构 它可以**存储一个固定大小的相同类型元素的顺序集合** 数组中的特定元素可以通过索引访问 **第一个索引值为 0** 数组都是由连续的内存位置组成 **最低的地址对应第一个元素**最高的地址对应最后一个元素 可以随机访问 查找方便

**数组名即数组首元素地址是一个地址常量不能被改变**  int arr[2] = { 1, 2 }; *(arr + 1) -- 正确 *(++arr) -- 错误

## 1. 定义数组

需要指定元素的类型和元素的数量 **下标最大值为元素数量 - 1** 一维数组 arrSize 必须是一个大于零的整数常量 数据类型可以是任意有效的数据类型 **数组的大小是在编译时确定的而不是在运行时** C99 之前 数组元素的数量必须是编译时常量 C99 标准之后 引入了变长数组 vla 允许使用非常量表达式来定义数组的大小 为了确保兼容性和可移植性通常建议使用编译时常量来定义数组的大小 #define max 2 int arr[max] = {} 可以因为在**预处理阶段已经替换是常量**  const int max = 2 int arr[max] = {} 不可以因为 **虽然被 const 修饰成常量 但是它是运行时常量**

## 2. 初始化数组

- 完全初始化 指定数量 double balance[5] = { 1000.0, 2.0, 3.4, 7.0, 50.0 }; 通过初始化值的数量隐式推断 double balance[] = { 1000.0, 2.0 }  数组定义中通常建议明确指定数组大小 
- 部分初始化 对于静态存储期的数组 全局数组或静态数组 只提供部分初始化值未指定的元素将自动初始化为 0 double balance[5] = { 1000.0, 2.0 } double balance[5] = {}
- 指定索引的初始化 C99 标准引入了指定索引的初始化方式 允许在初始化时直接设置数组中特定索引位置的值 int arr[10] = {[0] = 1, [2] = 3, [5] = 7};  对于静态存储期的数组未明确初始化的元素将自动初始化为 0
- 字符数组的初始化 字符数组字符串可以通过字符串字面量进行初始化 空字符 在字面量最后 '\0' 将用于初始化数组 char str[] = "Hello World!"
- 静态数组的初始化 对于静态存储期的数组如全局数组或静态数组 初始化规则与自动数组相同 但静态存储期的数组在程序加载到内存开始执行之前就已经被初始化
- 未初始化的数组 未初始化元素值不确定 int arr[10]

> **数组一旦离开初始化的上下文不能直接对整个数组进行重新初始化 数组一旦定义其大小是固定的**

## 3. 访问数组元素

数组元素可以通过数组名称加索引进行访问 元素的索引是放在方括号内跟在数组名称的后边 为数组中某个元素赋值 balance[4] = 50.0; 

## 4. 数组长度

```c
int arr[] = {1, 2, 3, 4, 5};
int length = sizeof(arr) / sizeof(arr[0]); //-- 5
```



>  ```c
>  int arr[3] = {0, 1, 2};
>  int i = arr[0];
>  int *i = &arr[0];
>  int *i = arr;
>  int (*i)[3] = &arr;
>  ```



# 二维数组

多维数组最简单的形式是二维数组 本质上是一个一维数组的列表 int arr[] [3]  3 不能省略因为得告诉二维数组存放的类型

## 1. 初始化二维数组

- 完全初始化 指定数量 int arr[2] [4] = { {0, 1, 2, 3}, {4, 5, 6, 7}}; int arr[2] [4] = {0, 1, 2, 3, 4, 5, 6, 7};  隐式推断 int arr[] [2] = { {0,0}, {1,2}, {2,4}};
- 部分初始化 int arr[2] [3]={ {1,2,3}, 4, 5 }; int arr[3] [4]={ {1,2,3},{4,5,6} }; 1 2 3 0 4 5 6 0 0 0 0 0
- 错误初始化 int arr[3] [3]={ {1,2,3},4,5,{7,8,9} };  1 2 3 4 5 7 0 0 0 int arr[3] [3]={ {1},4,{7,8,9},{3,4,5} }; 1 0 0 4 7 3 0 0 0

## 3. 二维数组元素名称和类型

> ```c
> int arr[3][3] = {{0, 1, 2}, //-- 第一行一维数组的名字是 a[0]
>         		 	 {3, 4, 5}, //-- 第二行一维数组的名字是 a[1]
> 				 {6, 7, 8}};
> int i = arr[0][0];
> int *i = &arr[0][0];
> int *i = arr[0];
> int (*i)[3] = &arr[0];
> int (*i)[3] = arr;
> int (*i)[3][3] = &arr;
> ```



# 数组指针 指针数组 指针函数 函数指针 函数指针数组 重头戏在后面

- 数组：元素的个数 元素类型
- 函数：参数 返回值 
- 指针：指针的类型是什么 指针指向类型是什么

  

# 数组指针 指针数组 重头戏在后面

- 指针数组: 指针数组是一个数组 数组元素是指针 数组元素可以指向不同的内存位置
- 数组指针: 数组指针是指针指向整个数组 注意它的目标是整个数组而不是普通的指针那样指向的是数组的首个元素 定义数组指针可以不用指定数组大小因为 C 不会对其执行边界检查 int arr[2] = {0, 1} int (*p)[] = &arr;

>重头戏在后面 结合方式 [] 优先级 高于 * 优先级 先与 [] 结合 成为数组 然后 是 * 成为 指针数组 最后是类型 字符型 结合成为 字符指针数组

## 1. 整型指针数组

> ```c
> int *arr[3] = {&i, &j, &k};
> int *i = arr[0];
> int **i = &arr[0];
> int **i = arr;
> int *(*i)[3] = &arr;
> ```

## 2. 整型数组指针

> ```c
> int (*i)[3] = &arr;
> int (*j)[3] = i;
> int (**k)[3] = &i;
> ```

> ```c
> int (*p)[] = arr;
> ```



# 地址索引

>访问数组元素本质即地址加偏移量 在 C 或 C++ 中 地址的索引可以是负数 如果对一个指针使用负索引 比如 [-1] 这意味着从当前指针位置向前即向低地址方向移动相应的元素数量  (p += 2)[-1]  在这个例子中 [-1] 意味着从 p += 2后的新位置向前移动一个元素的位置
>
>数组 arr[i] [j] 等价 *( *(arr + i) + j) 指针 *( *(p+1)+2) 等价 p[1] [2] 可以从外面递推验证



# 静态分配与动态分配

## 1. 静态数组

静态数组 静态数组是指在编译时确定大小的数组大小固定 其大小在程序运行期间不能改变

### 1.1 静态数组的特点

- 内存分配：静态数组的内存通常分配在栈上 随着函数的调用和返回而自动管理
- 大小固定：在定义时指定大小 且在程序运行过程中不能更改
- 效率：由于在栈上分配内存 访问速度较快
- 生命周期：静态数组的生命周期始于其定义时 如果在函数内部定义 生命周期与函数的调用相同 如果在全局范围定义 生命周期贯穿整个程序运行

## 2. 动态数组

运行时手动分配内存 大小可变 动态数组是在运行时通过动态内存分配函数 malloc calloc 手动分配内存的数组

### 2.1 动态数组特点

- 内存分配：动态数组的内存空间在运行时通过动态内存分配函数手动分配 并存储在堆上 需要使用 malloc、calloc 等函数来申请内存 并使用 free 函数来释放内存

- 大小可变：动态数组的大小在运行时可以根据需要进行调整 可以使用 realloc 函数来重新分配内存 并改变数组的大小

- 生命周期：动态数组的生命周期由程序员控制 确保在不需要在使用完数组后手动释放内存以避免内存泄漏和访问无效内存的问题

- 动态数组的声明、内存分配和释放实例

  

# 动态分配内存的指针数组

```c
#include <stdlib.h> 

int arr_out = 3;  
int arr_in = 3;  

int **arr = (int **)malloc(arr_out * sizeof(int *)); 

if (arr == NULL) { //-- do while  
    return 1;
}

for (int i = 0; i < arr_out; i++) {  
    
    arr[i] = (int *)malloc(arr_in * sizeof(int)); 

    if (arr[i] == NULL) {
        for (j = 0; j < i; j++) {
            free(arr[j]);
        }
        free(arr);
        return 1;
    }

    for (int j = 0; j < arr_in; j++) { //-- 赋值
        arr[i][j] = i + j;  
    }  
}  

for (int i = 0; i < arr_out; i++) {  
    free(arr[i]);  
}  

free(arr); 
```





# 数组逆序 双指针

```c
bool reverseArr(int arr[], int size) { 
    int start = 0;  
    int end = size - 1;  
    int i = 0; //-- 缺点: 生命周期长 优点: 不必每次循环重新向内存申请空间 只申请访问赋值权限速度快
    while (start < end) {  
        i = arr[start];  
        arr[start] = arr[end];  
        arr[end] = i;  

        start++;  
        end--;  
    }  
	return true;
}
```



# 排序

## 1. Bubble

原理：每次两个数进行比较 从数组的前两个元素开始 如果前面的数 > 后面的数 就交换 第一趟会求出一个最大值 并且放在最后面 然后依此类推 经过最多 N-1 趟 排好序

```c
bool bubbleSort(int arr[], int size) {   
    for (int i = 0; i < size-1; i++) {        
        for (int j = 0; j < size-i-1; j++) {  
            if (arr[j] > arr[j+1]) { 
                arr[j] = arr[j] ^ arr[j + 1];
                arr[j + 1] = arr[j] ^ arr[j + 1];
                arr[j] = arr[j] ^ arr[j + 1]; 
            }  
        }  
    }  
    return true;
}  
```

## 2. 交换排序

```c
bool exchangeSort(int a[],int size){
    for(int i = 0; i < size - 1; i++){ //-- 控制 a[i] 的下标变换
        for(int j = i + 1; j < size; j++){ //-- 控制每一轮的内部比较过程
            if(a[i]>a[j]){   
                int k = a[i]; a[i] = a[j]; a[j] = k; 
            }
        } 
    }
    return 1;
}
```

## 3. 选择排序

```c
bool selectionSort(int a[],int size){
    for(int i = 0; i < size - 1; i++){ //-- 控制 a[i] 下标变化
        int k = i; //-- 最下值下标
        for(int j = i + 1; j < size; j++){
            if(a[k] > a[j]){
               k = j;  
            }
        }
        if(k != i){
             int it = a[i]; a[i] = a[k]; a[k] = it;
        }
    }
    return 0;
}
```

### 最值和最值下标

```c
int a[4] = {1, 2, 3, 4};

int max = a[0]; int imax = 0;

for(int i = 1; i <= 4; i++){
    max = max > a[i] max : a[i];
    imax = max == a[i] i : imax;
}
```

### 不重复随机数

```c
#include<stdlib.h>
#include<time.h>

int noRepeatRandom(int *arr, int size){
    srand(time(0));

    for(int i = 0; i < size; i++){
        arr[i] = rand() % 35 + 1;
        for(int j = 0; j < i; j++){
            if(arr[j] == arr[i]){
                i--;
                break;
            }
        }    
    }
    return 1;
}
```

### PascalTriangle

```c
int printPascalTriangle(int n){   
    int triangle[n][n] = {};
	for(int i=0 ; i < n; i++){	
		for(int j = 0; j <= i; j++){
			if(j == 0 || i == j){
				triangle[i][j] = 1;
			}else{
				triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];
			} 
			//-- triangle[i][j]
		}
	//-- 换行
	} 
    return 0;
}
```



# indicator 有则值无则指针 类型相同才能赋值

内存单元地址即为指针 指针变量是用来存放内存地址的变量 不能存放其他内容 每一个变量都有一个内存位置 内存位置都定义了地址 指针变量也有自己的地址 一个变量 由 存储类型 数据类型 变量名 变量值 变量地址 组成 所有实际数据类型 不管是整型、浮点型、字符型 还是其他的数据类型 对应指针的值的类型都是一样的都是一个代表内存地址的长的十六进制数 不同数据类型的指针之间唯一的不同是指针所指向的变量或常量的数据类型不同 32 位操作系统 地址字宽是 32 也就是说指针大小为 32 位

```c
int i = 20; //-- 最底层的数据存储了一个整数值
int *iP1 = &i; //-- iP1 指向 i 则 *iP1 就是 i 的值
int **iP2 = &iP1; //-- iP2 指向 iP1 则 *iP2 是 iP1 的值 即 i 的地址 而 **iP2 是 i 的值    
int ***iP3 = &iP2; //-- iP3 指向 iP2 则 *iP3 是 iP2 的值 即 iP1 的地址 **ip3 是 iP1 的值 即 i 的地址 ***iP3 是 i 的值
```

## 1. 野指针

野指针指的是一个指针变量虽然被赋予了内存地址但是这个地址是不确定的非法的内存区域

- 指针未初始化: 指针变量在定义后没有被赋予一个明确的、有效的内存地址就直接被使用了这样的指针可能指向任意位置导致程序行为不可预测
- 指针指向的内存被释放: 当一个指针指向的内存区域被 free 释放 该指针就变成了野指针 如果之后再次通过这个指针访问或修改内存就会导致程序崩溃或数据损坏 函数返回了一个指向局部变量的指针而该局部变量在函数返回后已经被销毁
- 指针越界: 如果指针被赋予了超出其原本指向数组范围的地址那么它也可能变成野指针 对指针进行错误的算术运算如加减一个不正确的偏移量也可能导致指针指向一个无效的内存地址

### 1.1 防止野指针出现

初始化指针变量确保它们在使用前有一个明确的、有效的值 在释放内存后将指针设置为 NULL 这样即使之后不小心使用了这个指针程序也会因为尝试访问 NULL 指针而崩溃 这种崩溃通常更容易调试和定位

空地址 NULL: 特殊的数据类型所有数据类型的基础 空类型并非无类型 NULL 是一个定义在标准库中的值为 0 的常量 操作系统上 程序不允许访问地址为 0 的内存 因为该内存是操作系统保留的 然而内存地址 0 有特别重要的意义它表明该指针不指向一个可访问的内存位置 按照惯例如果指针包含空值零值则假定它不指向任何东西

## 2. 指针的运算

- 指针与整数的运算 ++ -- + - 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度 如 int 就是 4 个字节
- 指针与指针的运算 两个指针相减得到这两个指针之间相差的元素个数
- 指针的比较 可以比较指针来确定它们的关系 指针比较主要用于确定两个指针是否指向相同的内存位置或确定一个指针是否位于另一个指针之前或之后 指针可以用关系运算符进行比较 !=  == < > <= >=

  

# 字符数组 vs 字符指针

字符数组的形式表示字符串 浪费内存 栈区存一份常量区存一份 但是好处是能修改字符串

字符指针形式表示字符串存放在常量区 指针中存放的是字符串在常量区的首地址栈区只分配 4 个字节节省内存 但是这种方式定义字符串不能修改字符串的内容

> 在 C 语言中对于字符串常量编译器通常会进行优化以避免不必要的内存重复分配 这意味着如果程序中出现了多个相同的字符串常量编译器会只在常量区中为该字符串分配一次空间并让所有指向该字符串的指针都指向这块共享的内存区域 对于不同的字符串常量的存储如 "hello" 和 "helloworld" 编译器会在常量区中分别为它们分配空间因为它们是不同的字符串



# Funcation

## 1. 定义函数

函数由一个函数头和一个函数主体组成 返回类型: 函数可以返回一个值 是函数返回的值的数据类型 函数名称: 这是函数的实际名称 函数名和参数列表一起构成了函数签名  形式参数: 数量是可选的 函数主体: 函数主体是包含一组执行任务的语句

## 2. 调用函数

参数: 当函数被调用时可以向参数传递值这个值被称为实际参数  返回值: 函数可以存储返回值

函数执行时进栈 执行结束时出栈 当程序调用函数时 程序控制权会转移给被调用的函数 被调用的函数执行已定义的任务 当函数的返回语句被执行时或到达函数的结束括号时 会把程序控制权交还给主程序

## 3. 函数参数

如果函数要使用参数则必须 statement 接受参数值的变量 这些变量称为函数的形式参数 形式参数在进入函数时被创建退出函数时被销毁

- 值传递 把实际值复制给函数变量 这种情况下修改函数内的形式参数不会影响实际参数 默认情况下传值调用
- 引用传递 形参为指向实参地址的指针 当对形参的指向操作时 就相当于对实参本身进行的操作



### 字符转数字

```c
int atio(const char* str){
    int flag = 1;
    if(*str == '-'){
        flag = -1;
        ++str;
    }
    int res = 0;
    for(str; *str; ++str){
        if('0' > *str || *str > '9'){
            return flag * i;
        }
        res = res * 10 + (*str - '0');
    }
    return flag * res;
}
```



## 4. 数组函数

数组函数是一个函数 函数返回数组 不允许返回一个完整的数组 但是可以通过指定不带索引的数组名来返回一个指向数组的指针 注意不能是栈区的数组因为一旦函数返回栈区销毁



## 5. 可变参数 

省略号之前的那个参数是 int 代表了要传递的可变参数的总数

```c
#include <stdarg.h>
int* storage(int iargs, ...) {
    static int arr[10] = {};
    va_list args; //-- 定义一个 va_list 类型的变量访问可变参数列表
    va_start(args, iargs); //-- 初始化 args 使其指向第一个可变参数

    int i = 0;
    for (i; i < iargs; i++) {      
        int value = va_arg(args, int); //-- 获取当前参数的值
        arr[i] = value;
    }

    va_end(args); //-- 清理 va_list 变量

    return arr;
}

int main() {
    int* result1 = storage(3, 1, 2, 3); //-- 可变参数函数传入不同数量的整数参数

    for(int i = 0; i< 3; ++i){
        //-- *(result1+i)
    }

    return 0;
}
```





# 数组到指针的衰退

函数传参 数组只能是地址 结构体 可以值传递 也可以地址传递

在 C 语言的函数参数列表中当声明一个数组作为参数时在内部进行一种称为 数组到指针的衰退 array-to-pointer decay 的处理 这种处理是C语言标准的一部分它规定了数组在函数参数中的行为 具体来说编译器会将其视为一个指向数组第一个元素的指针 这意味着函数只能看到指向数组第一个元素的指针 这个大小信息也不会被保留或传递给函数 因为 C 不会对形式参数执行边界检查 你可以通过其他方式如另一个参数传递给它的数组大小信息 这种处理的原因主要是出于效率和灵活性的考虑

- 效率 传递数组时如果直接复制整个数组 那么对于大型数组来说这将是非常低效的 通过传递指向数组第一个元素的指针函数可以直接操作原始数组而无需复制

- 灵活性 传递指针允许函数接受不同大小的数组只要它们的元素类型相同这使得函数更加通用和灵活



# 递归

## 1. 递归的基本思想

### 1.1 递归的核心在于 递 与 归 两个过程

- 递 指的是将问题分解为若干个规模较小与原问题形式相同的子问题 这些子问题可以通过与原问题相同的方法来求解

- 归 则是指这些子问题的求解过程会逐步简化直到达到一个明确的终点 即 基准情形或基准情况 然后从终点开始逐步返回最终解决原问题

### 1.2 递归定义通常需要满足两个条件

- 子问题须与原始问题为同样的事且更为简单

- 递归调用必须有一个明确的出口条件 即 基准情形 基准情形是递归的终止条件即不需要进一步递归就能直接求解的情形 基准情形的存在是防止无限递归栈溢出的关键

## 2. 递归的优缺点

- 优点 **代码简洁** 递归通常能以更少的代码行实现复杂的逻辑  **易于理解** 对于某些问题 递归的解决方式更加直观 易于理解和描述 **分治策略** 递归是实现分治策略的自然方式能够有效解决大规模问题

- 缺点 **栈溢出风险** 递归调用会占用大量的栈空间深层递归或大数据量问题可能导致栈溢出 **重复计算** 在某些情况下递归可能会导致重复计算相同的问题降低效率 **调试困难** 递归的调用栈可能很深使得调试变得复杂和困难

## 3. 递归的优化方法

- **尾递归优化** 如果递归调用是函数中的最后一个操作可以优化为尾递归 编译器能够自动将其转换为迭代从而节省栈空间

- **记忆化** 对于重复子问题使用一个数组或字典来缓存已计算的结果从而避免重复计算

- **迭代替换** 在可能的情况下考虑使用迭代或尾递归优化来替换递归以降低栈溢出的风险

  

### Fibonaci

```c
int fibonaci(int n) { //-- 30 以上递归
    if (n == 1 || n == 2) { return 1; }
    return fibonaci(n - 1) + fibonaci(n - 2);
}
```

```c
int main(){ //-- 30 以下迭代
    int arr[31] = {1, 1};
    for(int i = 2; i < 30; i++){
        arr[i] = arr[i - 1] + arr[i -2];
    }
    return 0;
}
```



# 指针函数 函数指针 函数指针数组

## 1. 指针函数是一个函数 函数返回指针



## 2. 函数指针是一个指针 指针指向函数

### 2.1 定义函数指针的步骤

1. 复制函数的声明
2. 将函数名替换成 (*p)
3. 将不重要的形参名去掉
4. 将函数名赋值给指针 p

```c
int max(int v1, int v2){
    return v1 > v2 v1 : v2;
}

int main(void){
    int (*P)(int, int) = & max; //-- P 是函数指针 & 可以省略
    int i1 = 0, i2 = 0, i3 = 0, i4 = 0;
    i4 = P(P(v1, v2), v3); //-- 等价 i4 = max(max(a, b), c)
    return 0;
}
```

### 2.2 回调函数

回调函数是通过函数指针调用的函数 这种机制允许你将一个函数作为参数传递给另一个函数 并在适当的时机 比如异步操作完成或特定事件发生时 调用这个回调函数 回调函数广泛用于事件处理、异步编程、以及底层任务 系统级任务

```c
int callBack(int result) { //-- 实现一个回调函数
    //-- Callback function called with result
    return 1;
}

int callFunction(int (*callback)(int), int data) { //-- 定义一个接受回调函数的函数
    int Data = data * 2;
    callback(Data); //-- 调用回调函数
    return 1;
}

int main() {
    int data = 5;
    int (*Callback)(int) = callBack;
	callFunction(Callback, data); //-- 调用 callFunction 传递 Callback 作为回调函数
	return 0;
}
```

## 3. 函数指针数组



# 数组 指针 函数 总结

```c
1. int p[3]; //-- 整型数组
2. int (*p)[3]; //-- 整型数组指针
3. int *p[3]; //-- 整型指针数组
4. int *p(int); //-- 整型指针函数
5. int (*p)(int); //-- 整型函数指针
6. int *(*p)(int); //-- 整型指针函数指针
7. int (*p[3])(int); //-- 整型函数指针数组
8. int *(*p[3])(int); //-- 整型指针函数指针数组
```



# struct

结构是一种自定义的可用的数据类型 允许您存储不同类型的数据项 结构体中的数据成员 可以是基本数据类型 可以是其他结构体类型 指针类型 

## 1. 访问成员

- .  结构体变量访问成员变量 

- -> 结构体指针访问成员变量 

## 2. 结构体指针: 结构体指针是指针 指向结构体

```c
struct Class{
    int i1;
}  obj1 = {10}, *obj2 = &obj1;
```


结构体做函数参数

c
struct Class{
    int i1;
};
int function(struct Class obj)


省略类型直接定义变量

c
struct{
    int i1;
} obj; 


结构体数组

c
struct Class{
    int i1;
};
struct Class arr[2] = {1, 2};


结构体内存对齐的规则 即 结构体字节数

32 bit 字长的 CPU 每行 4 字节 首先找出最大元素字节数 如果数据大小超过 CPU 最大读取字节则以 CPU 最大字节为为存储单位 进行换行存取  不够则以元素最大字节为存储单位 64 bit 字长的 CPU 每行 8 字节 规则同上

结构体嵌套

c
struct Class1{
    int i1;

}  obj1 = {10}, *obj2 = &obj1;

struct Class2{
    struct Class1 obj3;
    struct Class1* obj4;
};


别名

c
typedef struct Class{
    int i1;
} Class1, Class2;



# field



位域 位段 bit-field 一种特殊的结构体成员 允许按位对成员进行定义 指定其占用的位数 如在存放一个开关量时 只有 0 和 1 两种状态 用 1 位二进位即可 位域必须为整数类型 字符 枚举 可以单独使用 也可以与其他成员一起组成结构体 位域可能并不占用连续的内存空间 不能将位域成员的地址作为函数参数传递 宽度不能超过其数据类型的大小 位域可以是无名位域 即 空域 它只用来作填充或调整位置是不能使用的

结构最小将占用 4 个字节的内存空间 如果您用了 32 个变量 每一个变量宽度为 1 位 占 4 个字节 但只要您再多一个变量 将分配内存的下一段来存储第 33 个变量 这个时候就开始占用 8 个字节 出现不同类型无论是否为 field 如 整型 字符型 整型 占 12 字节 或者 字符型 整型 字符型 占 12 字节

c
struct Bit{
    unsigned int i; -- 正确 sizeof(status.i)
    unsigned int is0 : 1; -- 错误 sizeof(status.is0)
    unsigned int is1 : 1;
    unsigned int is2 : 2;
    unsigned int is3 : 2;
    unsigned int is4 : 3;
    unsigned int :23;
    unsigned int isi : 32;
    unsigned long long isll : 33;
} bit; -- 正确 sizeof(bit)



# 枚举



枚举是定义一组具有离散值的常量 它可以让数据更简洁更易读 第一个枚举成员的默认值为整型的 0 后续枚举成员的值在前一个成员上加 1 可以在定义枚举类型时改变枚举元素的值后面元素加 1

枚举变量的定义 

c
enum Color { RED, GREEN, BLUE };  
int main() {  
    enum Color color = RED;  
    if (color == RED) {  
        --isRED 
    }
    return 0;  
}



# 共用体



共用体是一种特殊的数据类型 允许您在相同的内存位置存储不同的数据类型 您可以定义一个带有多成员的共用体 但是任何时候只能有一个成员带有值 共用体占用的内存应足够存储共用体中最大的成员 最后赋给变量的值占用了内存位置 前面值可能有损坏 可以同一时间只用一个成员 定义共用体 必须使用 union 语句



file



一个文件 无论它是文本文件还是二进制文件 都是代表了一系列的字节 C 语言不仅提供了访问顶层的函数 也提供了底层 OS 调用来处理存储设备上的文件

写入文件

c
int main(){
    FILE *fp = NULL;
    fp = fopen("./1.txt", "w+");
    fprintf(fp, "FPRINTF");
    fputs("FPUTS", fp);
    fclose(fp);
    return 0;
}


读取文件

c
int main(){
    FILE *fp = NULL;
    char buff[255] = {};
    fp = fopen("./1.txt", "r");
    fscanf(fp, "%s", buff);
    fgets(buff, 255, (FILE*)fp);
    fgets(buff, 255, (FILE*)fp);
    fclose(fp);
    return 0;
}




ERROR



C 语言不提供对错误处理的直接支持 但是作为一种系统编程语言 它以返回值的形式允许您访问底层数据 在发生错误时 大多数的 C 或 UNIX 函数调用返回 1 或 NULL 同时会设置一个错误代码 errno 该错误代码是全局变量表示在函数调用期间发生了错误 可以在 errno.h 头文件中找到各种各样的错误代码 所以 C 程序员可以通过检查返回值然后根据返回值决定采取哪种适当的动作 开发人员应该在程序初始化时把 errno 设置为 0 这是一种良好的编程习惯 0 值表示程序中没有错误

打开一个不存在的文件 

c
#include <stdio.h>
#include <errno.h>
#include <string.h>

extern int errno;

int main (){
    FILE * pf = NULL;
    int ierr = 0;
    pf = fopen ("./1.txt", "rb");
    if (pf == NULL){
		ierr = errno;
        fprintf(stderr, "错误号: %d", errno);
        perror("PERROR 打开文件错误");
        fprintf(stderr, "STRERROR 打开文件错误: %s", strerror( ierr ));
    }
    else{
        fclose (pf);
    }
    return 0;
}


被零除的错误

c
#include <stdio.h>
#include <stdlib.h>

int main(){
    int dividend = 20;
    int divisor = 0;
    int quotient = 0;

if( divisor == 0){
    fprintf(stderr, "除数为 0 退出运行...");
    exit(-1);
}
quotient = dividend / divisor;
fprintf(stderr, "QUOTIENT 变量的值为: %d", quotient );

exit(0);

}


程序退出状态 通常情况下 程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS 这里 EXIT_SUCCESS 是宏 它被定义为 0  如果程序中存在一种错误情况 当您退出程序时会带有状态值 EXIT_FAILURE 被定义为 -1

c
#include <stdio.h>
#include <stdlib.h>

int main(){
    int dividend = 20;
    int divisor = 5;
    int quotient = 0;

if( divisor == 0){
    fprintf(stderr, "除数为 0 退出运行...");
    exit(EXIT_FAILURE);
}
quotient = dividend / divisor;
fprintf(stderr, "QUOTIENT 变量的值为: %d", quotient );

exit(EXIT_SUCCESS);

}



# io.h include <stdio.h>



printf 格式化输出函数 函数原型 int printf(const char *format, ...)

格式字符 放最后

d 以十进制形式输出带符号整数 正数不输出符号 

u 以十进制形式输出无符号整数

lu 32 位无符号整数

llu 64 位无符号整数

o 以八进制形式输出无符号整数不输出前缀 0 

X 以十六进制形式输出无符号整数不输出前缀 OX

f 以小数形式输出单、双精度实数

E 以指数形式输出单、双精度实数 

c 输出单个字符 

s 输出字符串 从字符串的首地址开始输出直到碰到 '\0' 结束

p 输出指针地址

flag

- 在给定的字段宽度内左对齐 默认是右对齐

+ 显示结果正负 即正数前面会显示 + 号 默认情况只有负数前面会显示一个 - 号

对于八进制和十六进制前面补零 对于其他输出无效

0 在指定填充 Padding 的数字左边放置 0

空格 如果没有写入任何符号则在该值前面插入一个空格

宽度
i 数字 要输出的字符的最小数目如果输出的值短于该数结果会用空格填充 如果输出的值长于该数结果不会被截断

精度

.i 数字 对于整数指定了要写入的数字的最小位数 如果写入的值短于该数结果会用前导 0 来填充 如果写入的值长于该数结果不会被截断 精度为 0 意味着不写入任何字符 对于小数在小数点后输出的小数位数 对于 s 要输出的最大字符数 默认情况下所有字符都会被输出直到遇到末尾的空字符 当未指定任何精度时默认为 1 如果指定时不带有一个显式值则假定为 0

返回值 如果成功则返回写入的字符总数 失败返回一个负数



```c
"%d %d %d %d %d", a++, ++a, a++, ++a, ++a
14 15 12 15 15
```



scanf 格式化输入函数 函数原型 int scanf(const char *format, ...)  阻塞 外界到程序

格式字符 放最后

c 读取单个字符 如果指定了一个不为 1 的宽度会读取指定宽度字符数 把它们存储在数组中连续位置 末尾不会追加空字符

d 读取十进制有符号整数 -2

u 读取无符号的十进制整数

o 读取八进制整数

X 读取十六进制整数

i 读入十进制 八进制 十六进制整数

E f 读取浮点数 -2.1 2E-2 

s 读取字符串 将读取连续字符直到遇到 空格、换行、制表符 

p 读入一个指针

宽度

i 数字 指定了在当前读取操作中读取的最大字符数

返回值 如果成功该函数返回成功匹配和赋值的个数 如果到达文件末尾或发生读错误则返回 EOF



fopen 创建一个新的文件或者打开一个已有的文件 函数原型 FILE *fopen( const char *filename, const char *mode )

filename 字符串 表示要打开的文件名称

mode 字符串 表示文件的访问模式可以是以下表格中的值

r  打开一个已有的文本文件 读取文件

w打开一个文本文件 文件不存在则创建文件 文件存在清空写入

a打开一个文本文件 文件不存在则创建文件 文件存在追加模式写入文件 


r+打开一个文本文件 读写文件 覆盖写入 打开不存在的文件 fopen 将返回 NULL 并且设置 errno 为 ENOENT 表示文件不存在


w+打开一个文本文件 读写文件 文件不存在则创建文件 文件存在则清空写入


a+打开一个文本文件 读写文件 文件不存在则创建文件 文件存在则追加写入 读取从文件的开头开始

如果处理的是二进制文件 则需使用下面的访问模式来取代上面的访问模式 "rb" "wb" "ab" "rb+" "r+b" "wb+" "w+b" "ab+" "a+b"

返回值 该函数返回一个 FILE 指针 否则返回 NULL 且设置全局变量 errno 来标识错误



fclose 清空缓冲区中的数据关闭文件并释放用于该文件的所有内存 函数原型 int fclose(FILE *stream)

stream 指向 FILE 对象的指针 该 FILE 对象指定了要被关闭的流

返回值 如果流成功关闭则该方法返回零 如果失败则返回 EOF EOF 是一个定义在头文件 io.h 中的常量



fgetc 在指定的流 stream 获取下一个无符号字符 把位置标识符往前移动 函数原型 int fgetc( FILE * fp )

stream 这是指向 FILE 对象的指针 该 FILE 对象标识了要在上面执行操作的流

返回值 该函数以无符号字符强制转换为 int 的形式返回读取的字符 如果到达文件末尾或发生读错误则返回 EOF



fgets 在指定的流 stream 读取一行并把它存储在 str 所指向的字符串内 当读取 n-1 个字符时 读取到换行符时 到达文件末尾时 会停止读取 函数原型 char *fgets( char *buf, int n, FILE *fp )

str指向一个字符数组的指针该数组存储了要读取的字符串

n 这是要读取的最大字符数 包括最后的空字符 通常是使用以 str 传递的数组长度

stream 这是指向 FILE 对象的指针该 FILE 对象标识了要从中读取字符的流

返回值 成功该函数返回相同的 str 参数 如果到达文件末尾或者没有读取到任何字符 str 的内容保持不变并返回一个空指针 如果发生错误返回一个空指针





fread 在给定流 stream 读取数据到 ptr 所指向的数组中 函数原型 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)

ptr 指向带有最小尺寸 size * nmemb 字节的内存块的指针

size 这是要读取的每个元素的大小以字节为单位

nmemb 元素的个数 每个元素的大小为 size 字节

stream 指向 FILE 对象的指针 该 FILE 对象指定了一个输入流

返回值 成功读取的元素总数会以 size_t 对象返回 size_t 对象是一个整型数据类型 如果总数与 nmemb 参数不同则可能发生了一个错误或者到达了文件末尾





fflush 刷新流 stream 的输出缓冲区 函数原型 int fflush(FILE *stream)

stream 这是指向 FILE 对象的指针 该 FILE 对象指定了一个缓冲流

返回值 如果成功该函数返回零值 如果发生错误则返回 EOF 且设置错误标识符





fputc  函数 fputc 把参数 c 的字符值写入到 fp 所指向的输出流中 请确保您有目录 如果不存在该目录 则需要在您的计算机上先创建该目录 函数原型 int fputc( int c, FILE *fp )

char 这是要被写入的字符 该字符以其对应的 ASCII 值进行传递

stream 这是指向 FILE 对象的指针 该 FILE 对象标识了要被写入字符的流

返回值 如果没有发生错误则返回被写入的字符 如果发生错误则返回 EOF 并设置错误标识符



fputs 把字符串写入到指定的流 stream 中 但不包括空字符 函数原型 int fputs( const char *s, FILE *fp )

str 这是一个数组包含了要写入的以空字符终止的字符序列

stream 这是指向 FILE 对象的指针该 FILE 对象标识了要被写入字符串的流

返回值 该函数返回一个非负值如果发生错误则返回 EOF



fwrite 把 ptr 所指向的数组中的数据写入到给定流 stream 中 函数原型 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)

ptr 这是指向要被写入的元素数组的指针

size 这是要被写入的每个元素的大小以字节为单位

nmemb 这是元素的个数 每个元素的大小为 size 字节

stream 这是指向 FILE 对象的指针 该 FILE 对象指定了一个输出流

返回值 如果成功该函数返回一个 size_t 对象表示元素的总数该对象是一个整型数据类型 如果该数字与 nmemb 参数不同则会显示一个错误



fprintf 发送格式化输出到流 stream 中 函数原型 int fprintf(FILE *fp,const char *format, ...)

stream 这是指向 FILE 对象的指针 该 FILE 对象标识了流

format 这是 C 字符串 包含了要被写入到流 stream 中的文本

返回值 如果成功 则返回写入的字符总数否则返回一个负数



sprintf 发送格式化输出到 **str** 所指向的字符串函数原型 int sprintf(char *str, const char *format, ...)

- **str** -- 这是指向一个字符数组的指针，该数组存储了 C 字符串。
- **format** -- 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。



fscanf 在标准输入 stdin 读取格式化输入 函数原型 int fscanf(FILE *fp, const char *format, ...) 

 format 这是 C 字符串

返回值 如果成功该函数返回成功匹配和赋值的个数 如果到达文件末尾或发生读错误则返回 EOF



fseek 设置流 stream 的文件位置为给定的偏移 offset ，参数 offset 意味着从给定的 whence 位置查找的字节数。函数原型 int fseek(FILE *stream, long int offset, int whence)

- **stream** -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。
- **offset** -- 这是相对 whence 的偏移量，以字节为单位。
- **whence** -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：

如果成功，则该函数返回零，否则返回非零值。

SEEK_SET 文件的开头

SEEK CUR 文件指针的当前位置

SEEK END 文件的末尾



ftell 返回给定流 stream 的当前文件位置 函数原型 long int ftell(FILE *stream)

- **stream** -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。

返回值 该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。



perror 把一个描述性错误消息输出到标准错误 stderr 函数显示您传给它的字符串跟一个冒号一个空格和当前 errno 值的文本表示形式 函数原型 void perror(const char *str)

str 这是 C 字符串包含了一个自定义消息将显示在原本的错误消息之前









# string.h include <string.h>



strcat 字符串连接函数 函数原型 char *strcat(char *dest, const char *src)

！dest 指向目标数组 该数组大小足够容纳追加后的字符串

！src 指向要追加的字符串

返回值 该函数返回一个指向最终的目标字符串 dest 的指针



strcmp 字符串比较函数 逐字符比较 ASCII 函数原型 int strcmp(const char *str1, const char *str2)

str1 要进行比较的第一个字符串

str2 要进行比较的第二个字符串

返回值 如果返回值小于 0 则表示 str1 小于 str2 如果返回值大于 0 则表示 str1 大于 str2 如果返回值等于 0 则表示 str1 等于 str2



strcpy 字符串复制函数 函数原型 char *strcpy(char *dest, const char *src)

dest 指向用于存储复制内容的目标数组

src 要复制的字符串

返回值 该函数返回一个指向最终的目标字符串 dest 的指针



strlen 字符串长度计算函数 函数原型 size_t strlen(const char *str)

str 要计算长度的字符串

返回值 该函数返回字符串的长度



memset 将内存块清零或设置为特定值 函数原型 void *memset(void *str, int c, size_t n)

str 指向要填充的内存区域的指针

c 要设置的值通常是一个无符号字符

n 要被设置为该值的字节数

返回值 该值返回一个指向存储区 str 的指针



strerror 在内部数组中搜索错误号 errnum  函数原型 char *strerror(int errnum)

errnum 错误号通常是 errno

返回值 该函数返回一个指向错误字符串的指针该错误字符串描述了错误 errnum



# lib.h include <stdlib.h>



atio 字符串转整数数字函数 函数原型 int atoi(const char *str)

str 要转换为整数的字符串

返回值 该函数返回转换后的长整数 如果没有执行有效的转换则返回零



malloc 动态分配内存空间函数 函数原型 void *malloc(size_t size)

size 内存块的大小以字节为单位

返回值 函数返回一个指针指向已分配大小的内存 如果请求失败则返回 NULL

应该显示的进行类型转换  如果没有显式地进行类型转换 malloc 返回的 void* 指针会隐式地转换 在使用动态数组时需要检查内存分配是否成功 即 arr 是否为 NULL



calloc 动态分配内存空间函数 初始化分配的内存为零 函数原型 void *calloc(size_t nitems, size_t size)

nitems 要被分配的元素个数

size 元素的大小

返回值 该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL



realloc 重新申请的内存空间大小 指定的新的大小且原数据会放到新申请的空间中 函数原型 void *realloc(void *ptr, size_t size)

ptr 指向一个要重新分配内存的内存块 该内存块之前是通过调用 malloc、calloc、realloc 进行分配内存的 如果为空指针则会分配一个新的内存块

size 内存块的新的大小以字节为单位 如果大小为 0 且 ptr 指向一个已存在的内存块则指向的内存块会被释放并返回一个空指针

返回值 该函数返回一个指针指向重新分配大小的内存 请求失败则返回 NULL



free 释放动态分配的内存的函数 函数原型 void free(void *ptr)

ptr 指针指向一个要释放内存的内存块 该内存块之前是通过调用 malloc、calloc、realloc 进行分配内存的 如果传递的参数是一个空指针则不会执行任何动作



exit 立即终止调用进程 任何属于该进程的打开的文件描述符都会被关闭 该进程的子进程由进程 1 继承初始化 且会向父进程发送一个 SIGCHLD 信号 函数原型 void exit(int status)

status 给父进程的状态值



qsort 数组 快速排序 函数原型 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *));

base 指向待排序数组的第一个元素的指针

nitems 数组中的元素数量

size 数组中每个元素的大小以字节为单位

compar 比较函数的指针该函数用于比较两个元素 比较函数应当返回一个整数表示比较结果 小于零表示第一个元素小于第二个元素 等于零表示两个元素相等 大于零表示第一个元素大于第二个元素



(p += 2)[-1]：在C或C++中，数组的索引可以是负数。如果对一个指针使用负索引，比如[-1]，这意味着从当前指针位置向前（即向低地址方向）移动相应的元素数量。在这个例子中，[-1]意味着从p += 2后的新位置向前移动一个元素的位置。





全局快捷键冲突 clion



# long staging = *(int *) b - *(int *) a;

 将其存储在 `long` 中，但这个计算过程仍然是在 `int` 范围内进行的。

long staging = (long)*(int  *)b - (long) * (int *)a; 这样可以确保减法操作在更大的整数类型（`long`）上执行，从而避免溢出

您遇到的错误是由于类型不匹配和内存对齐问题引起的。在您的 `cmp` 函数中，您尝试将 `const void*` 类型的指针直接转换为 `long*` 类型的指针，然后解引用它们。但是，这种转换可能是不安全的，因为原始数据（即 `nums` 数组中的元素）是以 `int` 类型存储的，而不是 `long` 类型。此外，即使 `long` 和 `int` 在某些平台上大小相同，它们的对齐要求也可能不同，这可能导致未对齐的访问错误。



# cmd



在Windows系统中，若要通过指令或快捷键以管理员权限运行命令提示符（CMD），可以参考以下几种方法：



使用快捷键和指令

Win+R组合键：

按下键盘上的Win（Windows徽标键）和R键，打开“运行”对话框。

在对话框中输入cmd。

按住Ctrl、Shift和Enter键（同时按下），系统会弹出“用户账户控制”提示框，询问是否允许此程序进行更改。

点击“是”，即可以管理员身份运行CMD。

Win+X快捷键菜单：

在Windows 8.1及更高版本中，按下Win+X组合键可以打开Windows工具菜单（也称为“Win+X菜单”）。

在菜单中选择“命令提示符（管理员）”或“Windows PowerShell（管理员）”即可。

使用鼠标右键和指令

在开始菜单中搜索CMD：

打开开始菜单，在搜索框中输入cmd。

在搜索结果中找到“命令提示符”，右键点击它。

在弹出的菜单中选择“以管理员身份运行”。

在所有应用中找到CMD：

打开开始菜单，选择“所有应用”。

在Windows系统文件夹中找到“命令提示符”，右键点击它。

选择“以管理员身份运行”。

使用任务管理器

通过任务管理器的新建任务功能，也可以以管理员身份运行CMD。具体步骤为：

按Ctrl+Shift+Esc打开任务管理器。

点击“文件”菜单，选择“运行新任务”。

在“打开”框中输入cmd。

勾选“以系统管理权限创建此任务”，然后点击“确定”。

设置快捷键启动管理员CMD

还可以为管理员CMD设置一个快捷键，以便快速启动。具体步骤为：

在开始菜单的搜索框中输入cmd，找到命令提示符的快捷方式。

右键点击该快捷方式，选择“属性”。

在“快捷方式”选项卡中，点击“高级”按钮。

勾选“以管理员权限运行”，然后点击“确定”。

回到属性窗口，点击“快捷方式”选项卡中的“快捷键”框，设置一个自定义快捷键（如Ctrl+Alt+C）。

点击“确定”保存设置。

之后，你可以通过按下设置的快捷键来快速启动管理员CMD。







在Windows系统中，要以管理员权限快速启动PowerShell，你可以使用以下快捷键或命令：



快捷键方法

Win+X组合键：

按下键盘上的Win（Windows徽标键）和X键，打开Windows工具菜单（也称为“Win+X菜单”）。

在菜单中找到并选择“Windows PowerShell（管理员）”或“Windows PowerShell ISE（管理员）”，具体取决于你需要的PowerShell版本或界面。

任务管理器新建任务：

按Ctrl+Shift+Esc打开任务管理器，或者右键点击任务栏并选择“任务管理器”。

在任务管理器中，点击“文件”菜单，然后选择“运行新任务”。

在弹出的对话框中输入powershell，并勾选“以系统管理权限创建此任务”。

点击“确定”即可以管理员身份启动PowerShell。

命令方法

通过搜索启动：

在Windows的搜索框中输入PowerShell。

在搜索结果中找到“Windows PowerShell”或“Windows PowerShell ISE”，右键点击它。

在弹出的菜单中选择“以管理员身份运行”。

通过开始菜单启动：

如果PowerShell已经固定到开始菜单，你可以直接右键点击它，然后选择“以管理员身份运行”。

通过命令行提升权限（脚本方法）：

如果你已经在运行一个非管理员权限的PowerShell窗口，并且想要提升它的权限，这通常是不可能的，因为权限是在进程启动时确定的。但是，你可以编写一个脚本来检测当前权限，并提示用户以管理员身份重新启动该脚本。例如：

powershell

if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {

  \# 提示用户以管理员身份运行

  $arguments = "& '" + $myinvocation.mycommand.path + "'"

  Start-Process powershell -Verb runAs -ArgumentList $arguments

  exit

}

**# 你的管理员权限命令放在这里**

Write-Host "现在是以管理员权限运行"

将上述脚本保存为.ps1文件，并双击运行。脚本会检测当前权限，如果不足，则会提示用户以管理员身份重新启动该脚本。

请注意，使用管理员权限时要小心谨慎，因为错误的命令可能会导致系统问题或数据丢失。在执行任何需要管理员权限的操作之前，请确保你了解该操作的影响，并备份重要数据。





Win+R是Windows系统中的一个非常实用的快捷键组合，它的主要作用是打开“运行”对话框。通过这个对话框，用户可以快速执行各种命令或打开特定的程序、文件、文件夹等。以下是Win+R快捷键的详细功能介绍：



执行命令：用户可以在“运行”对话框中输入各种命令，如“notepad”打开记事本，“calc”打开计算器，“services.msc”打开服务管理器，“cmd”打开命令提示符等。

快速访问程序：除了执行命令，用户还可以直接输入程序的名称或路径来快速打开该程序，无需通过开始菜单或文件资源管理器查找。

管理系统设置：通过输入特定的命令或控制面板项的路径，用户可以快速访问并管理系统的各种设置，如网络连接、打印机设置等。例如，输入“control”可以打开控制面板，输入“regedit”可以打开注册表编辑器进行高级系统设置和管理。

执行复杂操作：Win+R还可以用于执行一些复杂的操作，如设置开机启动的程序（通过输入“shell:startup”打开启动文件夹，然后将想要开机启动的程序的快捷方式复制到其中）、访问系统文件夹等，这些操作通常需要输入特定的命令或路径。

快速访问文件夹：如果知道某个文件夹的路径，可以直接在“运行”对话框中输入该路径，然后按下回车键即可直接打开该文件夹，避免了多层文件夹的繁琐点击。

快速访问网址：Win+R也可以作为一个快速访问网址的工具。只需在“运行”对话框中直接输入网址，然后按下回车键，系统会自动使用默认的浏览器打开该网址。

使用Win+R可以大大减少用户寻找程序或执行命令所需的时间，从而提高工作效率。同时，它也提供了灵活的命令输入方式，用户可以根据自己的需求输入任何有效的命令或路径。只需同时按下键盘上的Windows徽标键（通常位于Ctrl和Alt之间）和R键，即可打开“运行”对话框，然后在对话框中输入所需的命令或程序名称，并点击“确定”按钮或按Enter键执行。



总的来说，Win+R是Windows系统中一个非常强大且实用的快捷键组合，它为用户提供了快速执行命令、访问程序和管理系统设置的便捷方式。















# markdown










# 线性表

线性表 包括 顺序表 链表 栈 队列

线性表的特征 逻辑结构是一对一的线性结构 逻辑关系是线性关系 每一个节点 其中首节点无前驱 尾节点无后继



# 顺序表 数组

逻辑结构 一对一的线性结构 存储结构 顺序存储结构 在内存中连续存储

- 优点 顺序表可以随机访问通过数组下标 查找方便通过数组下标
- 缺点 顺序表插入删除麻烦移动大量元素

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef int E;

/**
 * arr: 数组
 * size: 数组容量
 * length: 数组元素长度
 */
typedef struct {
    E *data;
    int size;
    int length;
} ArrList;

bool initArrList(ArrList *arrList) {
    arrList->size = 10;
    arrList->data = (E *) malloc(sizeof(E) * arrList->size);
    if (arrList->data == NULL) {
        fprintf(stderr, "initArrList malloc failed!\n");
        return 0;
    }
    arrList->length = 0;
    return 1;
}

bool createArrList(ArrList *arrList, int initialSize) {
    arrList->size = initialSize;
    arrList->data = (E *) malloc(sizeof(E) * arrList->size);
    if (arrList->data == NULL) {
        fprintf(stderr, "createArrList malloc failed!\n");
        return 0;
    }
    arrList->length = 0;
    return 1;
}

bool insertElement(ArrList *arrList, E element, int position) {
    if (position < 1 || position > arrList->length + 1) {
        fprintf(stderr, "insertElement position illegal!\n");
        return 0;
    }
    if (arrList->length == arrList->size) {
        int newSize = arrList->size + (arrList->size >> 1);
        E *newArr = (E *) realloc(arrList->data, sizeof(E) * newSize);
        if (newArr == NULL) {
            fprintf(stderr, "insertElement expansion malloc failed!\n");
            return 0;
        }
        arrList->data = newArr;
        arrList->size = newSize;
    }
    for (int i = arrList->length - 1; i >= position - 1; --i) {
        arrList->data[i + 1] = arrList->data[i];
    }
    arrList->data[position - 1] = element;
    arrList->length++;
    return 1;
}

bool isEmpty(ArrList *arrList) {
    return arrList->length == 0;
}

E deleteElement(ArrList *arrList, int position) {
    if (position < 1 || position > arrList->length) { //-- arrList->length
        fprintf(stderr, "deleteElement position illegal!\n");
        return 0;
    }
    int e = seqlist->data[position - 1];
    for (int i = position - 1; i < arrList->length - 1; ++i) {
        arrList->data[i] = arrList->data[i + 1];
    }
    arrList->length--;
    return e;
}

int getLength(ArrList *arrList) {
    return arrList->length;
}

int searchElement(ArrList *arrList, E e) {
    for (int i = 0; i < arrList->length; ++i) {
        if (e == arrList->data[i]) {
            return i + 1;
        }
    }
    return -1;
}

void clsArrList(ArrList *arrList) {
    arrList->length = 0;
}

void printArrList(ArrList *arrList) {
    for (int i = 0; i < arrList->length; ++i) {
        printf("%d ", arrList->data[i]);
    }
    printf("\n");
}

int main() {
    ArrList arrList = {};
//    if (!initArrList(&arrList)) {  // 默认初始化
//        return 1;
//    }
    if (!createArrList(&arrList, 20)) {  // 指定长度初始化
        return 1;
    }

    for (int i = 1; i <= 30; ++i) {
        insertElement(&arrList, i * 10, i);
    }
    printArrList(&arrList);
    printf("%d\n", arrList.length);
    printf("%d\n", arrList.size);
    free(arrList.data);
    return 0;
}
```



# 链表

单向链表 双向链表 单向循环链表 双向循环链表

逻辑结构：一对一的线性结构 存储结构：链式存储结构 通过指针将每一个节点连接起来在内存中是不连续存储的

- 链表的优点：
  (1)插入删除方便只要改变指针的指向就可以
  (2)长度不固定可以存储大量元素
  链表的缺点：
  查找麻烦 消耗内存空间大





尾插入法 有一个尾指针时刻指向链表尾节点

砍头思想

移动双指针

单向链表 有头链表头节点数据域无效 先移动后使用 无头链表全部有效 先使用后移动 移除节点需要找到要移除的前一个结点 清空链表两种思想 砍头法 和 双指针移动法



先连接前还是后取决于当前指针位置 指针在前 先连接后面 指针在后面先连接前面 保证数据不丢失

插入删除操纵 把指针移动到想插入删除位置前一个位置 保证后面数据不丢 移动到插入位置 保证前面数据不丢





边界判断

    for (int i = arrList->length - 1; i > position - 1; --i) {
        arrList->data[i + 1] = arrList->data[i];
    }





```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef int E;

typedef struct Node {
    E data;
    struct Node *next;
} LinkNode;

LinkNode *createLinkList() {
    LinkNode *p = (LinkNode *) malloc(sizeof(LinkNode));
    if (!p) {
        fprintf(stderr, "createLinkList malloc failed!\n");
        return NULL;
    }
    p->next = NULL;
    return p;
}

void destoryLinkList(LinkNode *p) {
    LinkNode *pHead = p;
    LinkNode *del = p;
    while (pHead->next) {
        pHead = pHead->next;
        free(del);
        del = pHead;
    }
}

bool isEmpty(LinkNode *p) {
    if (!p->next) { return 1; }
    return 0;
}

int linkListLength(LinkNode *p) {
    int len = 0;
    while (p->next) {
        p = p->next;
        ++len;
    }
    return len;
}

int searchLinkList(LinkNode *p, E e) {
    int i = 1;
    while (p->next) {
        p = p->next;
        if (p->data == e) { return i; }
        ++i;
    }
    return -1;
}

bool insertElementLinkList(LinkNode *p, int position, E e) {

    if (position < 1 || position > linkListLength(p) + 1) {

        fprintf(stderr, "insertElementLinkList position illegal!\n");
        return 0;
    }

    LinkNode *pNewNode = (LinkNode *) malloc(sizeof(LinkNode));
    if (!pNewNode) {
        fprintf(stderr, "insertElementLinkList malloc failed!\n");
        return 0;
    }

    pNewNode->data = e;
    pNewNode->next = NULL;

    for (int i = 0; i < position - 1; ++i) {
        p = p->next;
    }

    pNewNode->next = p->next;

    p->next = pNewNode;

    return 1;
}

bool deleteElementLinkList(LinkNode *p, int position) {
    if (position < 1 || position > linkListLength(p)) {
        fprintf(stderr, "deleteElementLinkList position illegal!\n");
        return 0;
    }

    for (int i = 0; i < position - 1; ++i) {
        p = p->next;
    }
    LinkNode *pDel = p->next;
    p->next = p->next->next;
    free(pDel);

    return 1;
}

bool clsLinkList(LinkNode *p) {

#if 0
    //砍头
    while (p->next) {
        LinkNode *pDel = p->next;
        p->next = p->next->next;
        free(pDel);
    }
    p->next = NULL;
#endif

    //双指针
    LinkNode *pHead = p;
    p = p->next;
    while (p) {
        LinkNode *pDel = p;
        p = p->next;
        free(pDel);
    }
    pHead = NULL;
    return 1;
}

bool desLinkList(LinkNode *p){
    while(p){
        LinkNode *pDel = p;
        p = p->next;
        free(pDel);
    }
    return 1;
}

void reverseLinklist(LinkNode *head) {

    if (head == NULL || head->next == NULL) return;

    LinkNode *fast = head->next;
    LinkNode *slow = head->next;
    head->next = NULL;

    while (fast) {
        slow = fast;
        fast = fast->next;
        slow->next = head->next;
        head->next = slow;
    }
}


//template<typename DataType>
//void Linklist<DataType>::Reverse() {
//    Node<DataType>* p, * s;
//    p = first->next;
//    first->next = nullptr;
//    while (p != nullptr) {
//        s = p;
//        p = p->next;
//        s->next = first->next;
//        first->next = s;
//    }
//}



void printLinkList(LinkNode *p) {
    while (p->next) {
        p = p->next;
        printf("%d ", p->data);
    }
}

//void printLinkList(LinkNode *p) {
//    while (p) {
//        printf("%d ", p->data);
//        p = p->next;
//    }
//}

int main(int argc, const char *argv[]) {
    LinkNode *p = createLinkList();
    if (!p) { return -1; }

    insertElementLinkList(p, 1, 10);
    insertElementLinkList(p, 2, 20);
    insertElementLinkList(p, 3, 30);

    printLinkList(p);

    printf("\n");

    printf("%d ", searchLinkList(p, 30));

    printf("\n");

    deleteElementLinkList(p, 2);

    printLinkList(p);


    destoryLinkList(p);
    return 0;
}
```



单向循环链表



双向链表



双向循环链表



约瑟夫



顺序表和链表区别

1、顺序表和链表都是线性结构 都是一对一 顺序表是顺序存储结构 在内存中是连续存储的 链表是链式存储结构 在内存
中是不连续存储的通过指针将每一个节点连接起来
2、顺序表长度固定 链表的长度不固定
3、顺序表查找方便 可以实现随机访问链表查找不方便顺序表插入删除麻烦需要移动大量元素 而链表插入删除方便
只需要改变指针的指向就可以
4、存储相同个数、相同类型数据时候，链表消耗的空间更大





malloc 和 do while



# 栈

只能在一端进行插入删除操作的线性表 称为栈进行插入删除操作这一端叫栈顶

先进后出后进先出 FILO LIFO First Input Last Output

用数组的思想实现栈就是顺序栈
用链表的思想实现栈就是链式栈

顺序栈

入栈：每次往顺序表的尾巴上插入data[last]=×;
出栈：每次删除顺序表中最后一个有效元素1ast--;
3.2 链式栈
入栈：每次往头结点后一个位置插入 只能
出栈：每次删除头结点后一个位置



```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef int E;

typedef struct stack {
    E *data;
    int length;
    int size;
} Stack;

bool createStack(Stack *p) {
    p->size = 10;
    do {
        p->data = (E *) malloc(sizeof(E) * p->size);
    } while (!p->data);
    p->length = 0;
    return 1;
}

bool pushStack(Stack *p, E e) {
    if (p->length == p->size) {
        int newSize = p->size + (p->size >> 1);
        E *newData = NULL;
        do {
            newData = (E *) realloc(p->data, sizeof(E) * newSize);
        } while (!newData);
        p->data = newData;
        p->size = newSize;
    }
    p->data[p->length] = e;
    p->length++;
    return 1;
}

E popStack(Stack *p) {
    return p->data[--p->length];
}

bool isFullStack(Stack *p) {
    return p->length == p->size;
}

bool isEmptyStack(Stack *p) {
    return p->length == 0;
}

E getTopStack(Stack *p) {
    return p->data[p->length - 1];
}

void clsStack(Stack *p) {
    p->length = 0;
}

void to2(Stack *p, int n) {
    while (n) {
        pushStack(p, n % 2);
        n /= 2;
    }
    while (!isEmptyStack(p)){
        printf("%d", popStack(p));
    }
}

int main(int argc, const char *argv[]) {
    Stack s = {};
    Stack *p = &s;
    createStack(p);
//    pushStack(p, 1);
//    pushStack(p, 2);
//    pushStack(p, 3);
//    pushStack(p, 4);
//    pushStack(p, 5);
//    pushStack(p, 6);
//    pushStack(p, 7);
//    pushStack(p, 8);
//    pushStack(p, 9);
//    pushStack(p, 10);
//    pushStack(p, 11);
//
//    printf("%d\n", getTopStack(p));
//    popStack(p);
//    printf("%d\n", getTopStack(p));


    to2(p,10);

    free(p->data);
    return 0;
}
```



谎话国 实话国怎么去谎话国  问他们怎么去你的国家





# 队列



什么是队列
只允许在固定的两端进行插入和删除操作的线性表
7/头删尾插
一端进行插入操作
另一端进行删除操作
2、队列的特点(重点，记笔记）
先进先出后进后出
FIFO LILO
队列就是去银行办理业务先到的现办理先走后到的后办理后走



队列的实现方式
同栈一样
用顺序表实现队列思想就叫循环队列
用链表实现队列就叫链队列



循环队列 不超过一个数取余 进位思想





栈和队列总结

栈和队列都是只能在一端或者两端进行插入删除操作的线性表，都是线性结构，都可以用顺序存储或者链式存储来实现
其中，栈是先进后出后进先出的，进行插入删除元素的那一端叫栈顶
队列是先进先出后进后出的，进行插入元素那一端是队尾进行删除元素那一端是队头头删尾插



栈能模拟队列队列模拟不了栈 两个栈就成了队列



# 树

树的特征 树：一对多的树状结构层次关系一个节点可以对应多个后继一个节点只能对应一个前驱 根节点无前驱 叶节点无后继

树相关概念

度数：一个节点的子树个数//一个节点生儿子的个数
树的度数：整棵树中最大的节点度数//生儿子最能生的那个
叶子节点或者终端节点：度为0的节点//没生儿子的节点
分支节点：度不为0的节点//除了叶子节点
内部节点：除了根节点以外的分支节点//除了根节点和叶子节点
节点层次：根节点为1层根节点儿子那层为2层依次类推.．·
树的高度或者深度：树节点层次的最大值



二叉树

二叉树（Binary Tree）是n（n≥O）个节点的有限集合，它或者是空集（n=O），
或者是由一个根节点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。
二叉树与普通有序树不同，二叉树严格区分左孩子和右孩子，即使只有一个子节点也要区分左右。
二叉树：节点最大的度数2,同时二叉树严格区分左子和右子



二叉树常见术语 二叉树的常用术语如图7‑2所示。 ‧ 根节点（rootnode）：位于二叉树顶层的节点，没有父节点。 ‧ 叶节点（leafnode）：没有子节点的节点，其两个指针均指向 None 。 ‧ 边（edge）：连接两个节点的线段，即节点引用（指针）。 ‧ 节点所在的层（level）：从顶至底递增，根节点所在层为1。 ‧ 节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是0、1、2。 ‧ 二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。 ‧ 节点的深度（depth）：从根节点到该节点所经过的边的数量。 ‧ 节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。







二叉树特性（重点必须记住）
二叉树第k(k>=1)层上的节点最多2^(k-1)个
深度为k(k>=1)的二叉树最多有2^k-1个节点
任意一颗二叉树，度数为0节点的个数，都比度数为2的节点的个数多1   因为除了根节点之外，每个节点都是由其父节点的某一个子位置衍生出来的，而叶节点没有衍生出任何子节点。同时，度数为1的节点（只有一个子节点的节点）不影响这一平衡，因为它们只是从度数为2的节点“借用”了一个子节点的位置而没有增加或减少叶节点的数量。

脑子画三层图



二叉树遍历 **画圈 左侧为入口 每个节点分为前中后**

二叉树遍历，分为前序遍历 中序遍历后序遍历和层序遍历
层序：从上到下从左到右以此遍历：ABCDEF
前序（preorder）：根左右ABDCEF
中序（inorder）：左根右DBAECF
后序(postorder): 右根左 DBEFCA



前序:A BCEHFIJD GK//根左右

中序:AHE CIFJB DKG//左根右

求 后序：HEIJFCKG DBA//左右根

推图方法：前序第一个是根 后序最后一个是根 中序的根左都是左树右边是右树  第二种方法 找到根 遍历 前序或后序看在左还是右边没有左或右
1.先看前序或后序，找到根，在中序中将根标出来
2.中序中根标出来后，可以将剩余节点分两堆，根左侧
就是属于左子树，根右侧就属于右子树
3.根的左子或右子连谁，看前序或后序，谁离根近就连
谁
4.连上左子或右子之后，继续将连上的节点当做根节点
来看待，重复上面的操作



```c
typedef struct BitNode {
    char data;
    struct BitNode *lchild;
    struct BitNode *rchild;
} BitNode;

void preorder(BitNode *p) {
    if (!p) { return; }
    printf("%c ", p->data);
    preorder(p->lchild);
    preorder(p->rchild);
}

void inorder(BitNode *p) {
    if (!p) { return; }
    inorder(p->lchild);
    printf("%c ", p->data);
    inorder(p->rchild);
}

void postorder(BitNode *p) {
    if (!p) { return; }
    postorder(p->lchild);
    postorder(p->rchild);
    printf("%c ", p->data);
}

BitNode *createBitTree() {
    char c = 0;
    scanf("%c", &c);

    if (c == '#') {
        return NULL;
    }

    BitNode *root = (BitNode *) malloc(sizeof(BitNode));
    if (!root) { return NULL; }
    root->data = c;
    root->lchild = createBitTree();
    root->rchild = createBitTree();

    return root;
}

void desBitTree(BitNode *r) {
    if (r->lchild) { desBitTree(r->lchild); }
    if (r->rchild) { desBitTree(r->rchild); }

//    if (r->rchild) { desBitTree(r->rchild); }
//    if (r->lchild) { desBitTree(r->lchild); }

    printf("free:%c", r->data);
    printf("\n");
    free(r);
    return;

//    if(!r){ return;}
//    desBitTree(r->lchild);
//    desBitTree(r->rchild);
//
//    printf("free:%c", r->data);
//    printf("\n");
//
//    free(r);
}

int main(int argc, const char *argv[]) {
    BitNode *r = createBitTree();


    preorder(r);
    printf("\n");

    inorder(r);
    printf("\n");

    postorder(r);
    printf("\n");

    desBitTree(r);

    return 0;
}

//前序遍历非递归
/////////////////////////////////////////////////////////////
//template<typename DataType>
//void BiTree<DataType>::PreOrder(void) {
//    Stack<BiNode<DataType>*> S;
//    if (root != nullptr)  S.Push(root);
//    while (!S.Empty()) {
//        BiNode<DataType>* x;
//        x = S.Pop();        cout << x->data << " ";
//        if (x->rchild != nullptr)S.Push(x->rchild);
//        if (x->lchild != nullptr)S.Push(x->lchild);
//    }
//}
/////////////////////////////////////////////////////////////

//层序遍历
//////////////////////////////////////////////////////////////
//template<typename DataType>
//void BiTree<DataType>::LevelOrder(void) {
//    Queue<BiNode<DataType>*> Q;
//    if (root != nullptr) Q.EnQueue(root);
//    while (!Q.Empty()) {
//        BiNode<DataType>* x;
//        x = Q.DeQueue();        cout << x->data << " ";
//        if (x->lchild != nullptr)Q.EnQueue(x->lchild);
//        if (x->rchild != nullptr)Q.EnQueue(x->rchild);
//    }
//}
//////////////////////////////////////////////////////////////
```



二叉树数组表示 在链表表示下，二叉树的存储单元为节点 二叉树的各项基本操作。 那么，我们能否用数组来表示二叉树呢？答案是肯定的。 TreeNode ，节点之间通过指针相连接。上一节介绍了链表表示下的 7.3.1 表示完美二叉树 先分析一个简单案例。给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每 个节点都对应唯一的数组索引。 根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：若某节点的索引为𝑖， 则该节点的左子节点索引为2𝑖+1，右子节点索引为2𝑖+2。图7‑12展示了各个节点索引之间的映射关 系。

 表示任意二叉树 完美二叉树是一个特例，在二叉树的中间层通常存在许多 None 。由于层序遍历序列并不包含这些 此我们无法仅凭该序列来推测 None ，因 None 的数量和分布位置。这意味着存在多种二叉树结构都符合该层序遍历序 列。

为了解决此问题，我们可以考虑在层序遍历序列中显式地写出所有 None 。如图7‑14所示，这样处理后，层 序遍历序列就可以唯一表示二叉树了。示例代码如下： /* 二叉树的数组表示 */ // 使用 int 最大值标记空位，因此要求节点值不能为 INT_MAX int tree[] = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};

```c
typedef struct{
 int *tree;
 int size;
 } ArrayBinaryTree;
 /*构造函数*/
 ArrayBinaryTree *newArrayBinaryTree(int *arr, int arrSize) {
 ArrayBinaryTree *abt = (ArrayBinaryTree *)malloc(sizeof(ArrayBinaryTree));
 abt->tree = malloc(sizeof(int) * arrSize);
 memcpy(abt->tree, arr, sizeof(int) *arrSize);
 abt->size = arrSize;
 returnabt;
 }
 /*析构函数*/
 void delArrayBinaryTree(ArrayBinaryTree *abt) {
 free(abt->tree);
 free(abt);
 }
 /*列表容量*/
 int size(ArrayBinaryTree *abt) {
 returnabt->size;
 }
 /*获取索引为i节点的值*/

 int val(ArrayBinaryTree *abt, int i) {
 // 若索引越界，则返回 INT_MAX ，代表空位
if (i < 0 || i >= size(abt))
 return INT_MAX;
 return abt->tree[i];
 }
 /* 层序遍历 */
 int *levelOrder(ArrayBinaryTree *abt, int *returnSize) {
 int *res = (int *)malloc(sizeof(int) * size(abt));
 int index = 0;
 // 直接遍历数组
for (int i = 0; i < size(abt); i++) {
 if (val(abt, i) != INT_MAX)
 res[index++] = val(abt, i);
 }
 *returnSize = index;
 return res;
 }
 /* 深度优先遍历 */
 void dfs(ArrayBinaryTree *abt, int i, char *order, int *res, int *index) {
 // 若为空位，则返回
if (val(abt, i) == INT_MAX)
 return;
 // 前序遍历
if (strcmp(order, "pre") == 0)
 res[(*index)++] = val(abt, i);
 dfs(abt, left(i), order, res, index);
 // 中序遍历
if (strcmp(order, "in") == 0)
 res[(*index)++] = val(abt, i);
 dfs(abt, right(i), order, res, index);
 // 后序遍历
if (strcmp(order, "post") == 0)
 res[(*index)++] = val(abt, i);
 }
 /* 前序遍历 */
 int *preOrder(ArrayBinaryTree *abt, int *returnSize) {
 int *res = (int *)malloc(sizeof(int) * size(abt));
 int index = 0;
 dfs(abt, 0, "pre", res, &index);
 *returnSize = index;
 return res;
 }
 /* 中序遍历 */
 int *inOrder(ArrayBinaryTree *abt, int *returnSize) {
 int *res = (int *)malloc(sizeof(int) * size(abt));
 int index = 0;
 dfs(abt, 0, "in", res, &index);
 *returnSize = index;
 return res;
 }
 /* 后序遍历 */
 int *postOrder(ArrayBinaryTree *abt, int *returnSize) {
 int *res = (int *)malloc(sizeof(int) * size(abt));
 int index = 0;
 dfs(abt, 0, "post", res, &index);
 *returnSize = index;
 return res;
 }
```

 优点与局限性 二叉树的数组表示主要有以下优点。 ‧ 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。 ‧ 不需要存储指针，比较节省空间。 ‧ 允许随机访问节点。 然而，数组表示也存在一些局限性。 ‧ 数组存储需要连续内存空间，因此不适合存储数据量过大的树。 ‧ 增删节点需要通过数组插入与删除操作实现，效率较低。 ‧ 当二叉树中存在大量 None 时，数组中包含的节点数据比重较低，空间利用率较低



二叉搜索树



霍夫曼树（HuffmanTree），又称最优二叉树，是一类带权路径长度最短的树。

假设有n个权值{wl,w2,…,wn}，如果构造一棵有n个叶子节点的二叉树，而这n个叶子节点的权值是{wl,w2,…,wn}，则
所构造出的带权路径长度最小的二叉树就被称为霍夫曼树
树带权路径长度：
树的带权路径长度指树中所有叶子节点到根节点的路径长度与该叶子节点权值的乘积之和，
如果在一棵二叉树中共有n个叶子节点，用wi表示第i个叶子节点的权值，Li表示第i个叶子
节点到根节点的路径长度，则该二叉树的带权路径长度



霍夫曼树特征（记笔记）
(1)赫夫曼树的左右子树可以互换，因为这并不影响树的带权路径长度。
(2)带权值的节点都是叶子节点，不带权值的节点都是某棵子二叉树的根节点。
(3)权值越大的节点越靠近赫夫曼树的根节点，权值越小的节点越远离赫夫曼树的根节点。
(4)赫夫曼树中只有叶子节点和度为2的节点，没有度为1的节点。



霍夫曼树构建  29 12 15 6 23
（1)将给定的n个权值看做n棵只有根节点（无左右孩子）的二叉树，组成一个集合HT，每棵树的权值为该节点的权值。对
四个二叉树，按照权值进行排序,排完序之后，前两个就是最小的
（2)从集合HT中选出2棵权值最小的二叉树，组成一棵新的二叉树，其权值为这2棵二叉树的权值之和。
（3)将步骤2中选出的2棵二叉树从集合HT中删去，同时将步骤2中新得到的二叉树加入到集合HT中。位置：1
(4)重复步骤2和步骤3，直到集合HT中只含一棵树，这棵树便是赫夫曼树。



霍夫曼编码 左 0 右 1



二叉树的退化 图7‑8展示了二叉树的理想结构与退化结构。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所 有节点都偏向一侧时，二叉树退化为“链表”。 ‧ 完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。 ‧ 链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至𝑂(𝑛)。







# 算法

算法就是准确解决某种问题的计算步骤或者思想描述 





## 1. 时间复杂度 运行这个程序所消耗时间的趋势

时间复杂度只不过是对算法运行时间和处理问题规模之间关系的一种估算描述，将其理解成时间消耗多与少的一种趋势 一个算法的时间复杂度越高，说明这个算法在处理问题时所花费的时间越长。

俗话说：算法没有优劣之分，只有快慢之别
不同的算法适用于不同的场景，算法之间本身没有好与坏的区别，有的只是在处理相同规模问题的时候，谁快谁慢哪
种算法占用辅助空间更少的区别算法的时间复杂度和空间复杂度是用来衡量一个算法快慢与否以及运行时占用辅助空间大
小的一种计算标准，一般用o（)表示
这里需要特殊强调的是：算法的时间复杂度一般是无法精确计算的，因为一个算法在运行时消耗的时间是以毫秒为单
位来统计的但是因为计算机硬件配置的不同，所以同一个算法在不同计算机上，既是计算的是同一组数据，那么使用的时间
也是有很大差异的
例如：同样是使用冒泡排序对10万个随机正整数进行排序操作，在一台单核CPU的计算机上和在一台i7多核CPU的计
算机上进行计算，其运算时间一定是具有很大差异的
所以我们得出一个结论：算法的时间复杂度是不能精确计算的，所有算法的时间复杂度只不过是对算法运行时间和处
理问题规模之间，关系的一种估算描述//这句话记笔记

算法的可执行语句重复执行的频度
语句频度：算法中可执行语句重复执行的次数
通常时间复杂度用一个问题规模函数来表达
T(n)=o(f(n))
0时间度量级根据算法中语句执行的最大次数（频度）来估算一个算法执行时间的数量级。
f(n）函数关系表达式
它表示随问题规模n的增大，算法执行时间的增长率和f（n)的增长率相同。
在排序算法中，常见的时间复杂度有3种，分别是：0(n2)、o（nlogn)、o（n)
其中logn表示以2为底n的对数，这个值到底是怎么计算出来的，在快速排序算法中我们会详细进行分析
上述的3种时间复杂度之间的大小关系是：0（n2)（冒泡）>0（nlogn）（快排）>0（n）（顺序查找）
也就是说，时间复杂度为0(n^2)的排序算法运行效率最低，也就是最慢：时间复杂度为o(n)的排序算法运行效率最
高，也就是最快
n代表的是问题的规模
int a[100];//冒泡排序

>//代表算法优于的意思
>O(c) > O(1og2n）>O(n) > O(n*1og2n) > O(n^2）> O(n^3）> O(2^n)



T(n)的量级通常有：
O(c)—一常数级，不论问题规模多大，T(n)一致，因而是理想的T(n)量级；
0(n)-线性级；0(n2).O(n3)-一一平方、立方级；
O(logn),O(n*logn))——对数、线性对数级；
0(2n)指数级，时间复杂度最差。



无论选择哪个底数，对数时间复杂度的增长趋势都是相同的。因此，在描述算法的时间复杂度时，我们通常省略底数，只写 *O*(log*n*)。



## 2. 空间复杂度 运行这个程序所消耗空间的趋势

1.2空间复杂度
俗话说：算法没有优劣之分，只有快慢之别
不同的算法适用于不同的场景，算法之间本身没有好与坏的区别，有的只是在处理相同规模问题的时候，谁快谁慢哪
-种算法占用辅助空间更少的区别算法的时间复杂度和空间复杂度是用来衡量一个算法快慢与否以及运行时占用辅助空间大
小的一种计算标准，一般用o（)表示
空间复杂度是用来衡量一个真法在运行过程当中，在除了保存原始数据的空间之外，还需要额外消耗多少空间的
-种衡量标准
举个例子：冒泡排序在执行过程中，只需要消耗一个临时变量，用来交换两个反序的元素即可，所以
冒泡排序的空间复杂度就是0(1)
空间复杂度和时间复杂度一样，也是用来描述算法问题规模和运算时消耗额外空间之间关系的一种表达式，并不是用来详细
计算数值的公式
排序算法中空间复杂度常见的也是有3种：0(1)、0(n)、0(1ogn)
而空间复杂度和时间复杂度相似的是，空间复杂度越高，就表示这个算法在运行过程中所需要消耗的额外空间也就越多
从这个角度来讲，上面的三种空间复杂度之间的关系可以看做：0(n）〉o(logn）＞0(1)
也就是说，在空间复杂度层面来讲，0(1)是最小的空间复杂度





### 时间复杂度

时间复杂度衡量算法执行时间随输入规模增长的趋势，用大O符号表示，忽略低阶项和常数因子。它关注算法在最坏情况下的性能。

### 空间复杂度

空间复杂度衡量算法在执行过程中所需存储空间随输入规模增长的趋势，同样用大O符号表示。它主要关注除输入数据外的额外存储空间需求。







1 ~ 100 和

```c
for(int i = 1; i < 100; ++i) {
}
```

```c
(1 + 100) * 100 / 2
```

```c
for(int i = 0; i < n; ++i) { //-- i = 0 1 i = 1 2 i = 2 3 i = n - 1 n (1 + n - 1) * (n - 1) / 2 即 O(n^2/2 - n/2) --O(n^2)
    for(int j = 0; j <= i; ++j) {
    }
}
```





# 查找

## 1. 顺序查找 数据大效率低 可以无序

给定一个 n 个元素整型数组 arr 和一个目标值 target 写一个函数搜索 arr 中的 target 如果目标值存在返回下标 否则返回 -1

```c
int orderFind(int *arr, int size, int target){
    for (int i = 0; i < size; ++i) {
        if(arr[i] == e){
            return i;
        }
    }
    return -1;
}
```



> 时间复杂度：O(n) 其中 n 为数组的长度
> 空间复杂度：O(1) 



## 2. 二分查找-704 查找效率较快 有序

思想 假设序列递增 查找 target 找到中间元素 和 target 比较 如果比 target 大在序列左边找 如果比 target 小 在序列右边找

给定一个 n 个元素有序的升序整型数组 arr 和一个目标值 target 写一个函数搜索 arr 中的 target 如果目标值存在返回下标否则返回 -1

### 迭代实现

```c
int searchFind(int* arr, int size, int target) {
    int left = 0, right = size - 1;
    int mid = 0;

    while(left <= right){

        mid = (left + right) / 2;

        if (arr[mid] == target) {
            return mid;
        }

        if(arr[mid] < target){
            left = mid + 1;
        }else{
            right = mid - 1;
        }

    }
    return -1;
}
```

### 递归实现

```c
int searchFind(int *arr, int left, int right, int target) {
    if (left > right) { return -1; }
    int mid = (left + right) / 2;
    if (arr[mid] == target) { return mid; }
    if (arr[mid] < target) { searchFind(arr, mid + 1, right, target); }
    else { searchFind(arr, left, mid - 1, target); }
}
```



> 时间复杂度：O(logn) 其中 n 为数组的长度 二分查找所需的时间复杂度为 O(logn)  n / 2^k = 1  2^k = n k = logn
> 空间复杂度：O(1) 我们只需要常数空间存放若干变量



```c
35. 搜索插入位置 -- 有序数组 二分查找

给定一个排序数组和一个目标值 在数组中找到目标值并返回其索引 如果目标值不存在于数组中返回它将会被按顺序插入的位置

输入: nums = [1,3,5,6], target = 5
输出: 2
示例 2:

输入: nums = [1,3,5,6], target = 2
输出: 1
示例 3:

输入: nums = [1,3,5,6], target = 7
输出: 4
int searchInsert(int* nums, int numsSize, int target) {
    int left=0,right=numsSize-1;
    while(left<=right){
        int mid=(left+right)/2;
        if(nums[mid] < target){
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return left;
}
时间复杂度：O(logn) 其中 n 为数组的长度 二分查找所需的时间复杂度为 O(logn)
空间复杂度：O(1) 我们只需要常数空间存放若干变量
```



## 3. 分块查找 索引存储结构 块间有序块内可无序

先确定在哪个块中再去对应的块进行顺序插入/二分查找

```c
typedef struct {
    int max;
    int index;
} IndexList;

int indexBlockFind(int *arr, int size1, IndexList *indexList, int size2, int e) {
    int i = 0;
    for (i; i < size2; ++i) {
        if (e <= indexList[i].max) { break; }
    }
    if (i == size2) { return -1; }

    int start = indexList->index; // 开始下标
    int end = indexList[i + 1].index - 1; // 结束下标 = 下一块起始下标 - 1
    if (i == size2 - 1) {
        end = size1 - 1;
    }
    for (i = start; i <= end; ++i) {
        if (e == arr[i]) { return i; }
    }
    return -1;
}

int main(int argc, const char *argv[]) {
    int a[19] = {18, 10, 9, 8,
                 21, 20, 38, 42, 19,
                 50, 51, 72, 56, 55,
                 76, 100, 90, 88, 108};

    IndexList b[4] = {{18,  0},
                      {42,  4},
                      {72,  9},
                      {108, 14}};

    int i = indexBlockFind(a, 19, b, 4, 56);
    printf("%d ", i);
    return 0;
}
```



## 4. 哈希查找 散列查找 

散列存储结构：哈希表本质是一维数组通过哈希关系存的时候按照对应关系存取的时候按照对应关系取

扩展：因为有Hash冲突的存在，所以“Hash表的时间复杂度是o（1）"这句话并不严谨，极端情况下，如果所有
Key 的数组下标都冲突，那么 Hash 表就退化为一条链表，查询的时间复杂度是O(N)。但是作为一个面试题，“Hash
表的时间复杂度是0(1)”是没有问题的

```c
int hashRelation(int k) {
    return k - 1;
}

void depositVal(int *hashTable, int k, int val) {
    int i = hashRelation(k);
    hashTable[i] = val;
}

int hashFind(int *hashTable, int k) {
    return hashTable[hashRelation(k)];
}
```



统计字符出现次数

```c
#include <stdio.h>
#include <string.h>

int hashRelation(int k) {
    return k - 97;
}

void depositVal(int *hashTable, int k) {
    int i = hashRelation(k);
    hashTable[i]++;
}

int hashFind(int *hashTable, int k) {
    return hashTable[hashRelation(k)];
}

int main(int argc, const char *argv[]) {
    char a[] = "asdfasdlifadshjklrgeopaewrfpawedfoplhaqerqwrweqrterfgd";
    int hashlist[26] = {0};

    for (int i = 0; i < strlen(a); ++i) {
        depositVal(hashlist,a[i]);
    }

    for (int i = 0; i < 26; ++i) {
        printf("%d ", hashlist[i]);
    }
    printf("\n");
    printf("%d ", hashFind(hashlist, 'a'));

    return 0;
}
```





哈希函数（hash function）是将输入（键）映射到哈希表中的一个位置的函数。一个好的哈希函数应该具有以下特性：

- **均匀分布**：哈希函数应确保哈希值均匀分布在哈希表中，以减少冲突。
- **高效计算**：哈希函数的计算应该尽可能快速。
- **确定性**：相同的输入应始终产生相同的输出。

### 2. **处理哈希冲突**

哈希冲突（hash collision）是指两个或多个不同的键被映射到哈希表的同一位置。处理哈希冲突的方法包括：

- **链地址法（Separate Chaining）**：每个哈希表槽位存储一个链表或其他数据结构，以处理冲突。
- **开放地址法（Open Addressing）**：当发生冲突时，寻找下一个空闲槽位。常见的开放地址法包括线性探测（Linear Probing）、二次探测（Quadratic Probing）和双哈希（Double Hashing）。

### 3. **调整哈希表大小**

哈希表的性能与其装载因子（load factor，即表中元素数量与槽位数量的比值）密切相关。当装载因子过高时，冲突会增加，导致性能下降。因此，当装载因子超过某个阈值时（如0.75），应该考虑进行哈希表的扩容 在Java中，当负载因子超过0.75时，系统会将哈希 表扩容至原先的2倍。

### **动态调整哈希表**

- **自动扩容**：当装载因子过高时，自动分配更大的哈希表，并将现有元素重新哈希到新表中。

- **自动缩容**：当装载因子过低时，为了节省内存，可以自动缩小哈希表。

- ### **线程安全**

  在多线程环境中，哈希表的访问需要确保线程安全。可以使用锁（locking）、无锁数据结构（lock-free data structures）或并发哈希表（concurrent hash tables）来实现



> 时间复杂度：O(l) 



 Python采用开放寻址。字典 dict 使用伪随机数进行探测。 ‧ Java采用链式地址。自JDK1.8以来，当 HashMap 内数组长度达到64且链表长度达到8时，链表会转 换为红黑树以提升查找性能。

 哈希算法的目标 为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。 hash() 的设计上。 ‧ 确定性：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。 第6章 哈希表 hello‑algo.com 133 ‧ 效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。 ‧ 均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。 实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。 ‧ 密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希 值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹 配，那么密码就被视为正确。 ‧ 数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的 数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。 对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全 特性。 ‧ 单向性：无法通过哈希值反推出关于输入数据的任何信息。 ‧ 抗碰撞性：应当极难找到两个不同的输入，使得它们的哈希值相同。 ‧ 雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化。

标准哈希算法，例如MD5、SHA‑1、SHA‑2和SHA‑3等。它们可以将任意长 度的输入数据映射到恒定长度的哈希值





## 懒删除（lazydeletion）机制：它不直接从哈希表中移除元素，而是利用一个 常量TOMBSTONE来标记这个桶。





# 排序

算法问题的规模
所谓算法问题的规模，实际上就是对算法处理问题大小的一种抽象，我们一般习惯使用n、m等字符表示一个问题的规模
举一个比较实际的例子：例如一个排序算法是针对数组进行排序的，那么这个数组中的元素数量就可以认为是这个排序问题
的规模再比如说：使用二分搜索算法在一个ArrayList集合中查询一个指定元素的下标，那么这个集合的长度就可以看做
是这个二分搜索问题的规模所以：算法的规模实际上就是这个算法解决的问题中，保存数据多少的一种描述



1.3排序稳定性
排序算法的稳定性指的是，在一个排序算法处理的数组或者集合中，如果存在取值相同的元素，
那么在排序完成前后，这些取值相同的元素之间的相对顺序有没有发生变化
如果排序之后，取值相同元素之间的相对顺序没有发生变化，那么这个排序算法就是稳定的
如果排序之后，取值相同元素之间的相对顺序发生了变化，那么这个排序算法就是不稳定的

23345a245b
2392345a45b//稳定排序
2392345b45a//不稳定排序



冒泡排序



选择排序



插入排序 扑克牌

```c
void insertSort(int *arr, int size) {
    for (int i = 1; i < size; ++i) {
        for (int j = i; j > 0; --j) {
            if(arr[j] < arr[j - 1]){
                int t = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = t;
            } else {
                break;
            }
        }
    }
}
```



快速排序

```c
void quickSort(int *arr, int low, int high) {

    if (low >= high) { return; }

    int lo = low, hi = high;
    int flag = arr[low];

    while (arr[high] >= flag && low < high) { --high; }
    if (low < high) { arr[low++] = arr[high]; }

    while (arr[low] <= flag && low < high) { ++low; }
    if (low < high) { arr[high--] = arr[low]; }


//    while (low < high) {
//        while (arr[high] >= flag && low < high) { --high; }
//        if (low < high) { arr[low++] = arr[high]; }
//
//        while (arr[low] <= flag && low < high) { ++low; }
//        if (low < high) { arr[high--] = arr[low]; }
//    }
    arr[low] = flag;

    quickSort(arr, lo, high - 1);
    quickSort(arr, low + 1, hi);

}
```





照比权非比权力大
比较类//时间复杂度无法突破 nlogn
(1)冒泡排序
(2)选择排序
(3)插入排序
(4)快速排序
(5)堆排序
(6)希尔排序
(7)归并排序
非比较类／/时间复杂度是线性
(1)计数排序
(2)桶排序
(3)基数排序
2．时间复杂度分类
O(n^2)：冒泡排序 选择排序 插入排序-希尔排序(n^1.3)
O(nlogn)：快速排序 堆排序归并排序
线性：计数排序(n+k)桶排序(n+k）基数排序(n*k)
3．稳定性分类
稳定性：冒泡排序、插入排序、归并排序、计数排序(n+k)桶排序（n+k）基数排序（n*k)
不稳定：选择排序、快速排序、希尔排序、堆排序
4．时间复杂度和初始化顺序无关的有哪些?？／/最好和最坏时间复杂度一样
选择排序、堆排序、归并排序、计数排序、基数排序
5．希尔排序是对插入排序的优化



**内部排序**：
内部排序，又称内排序，是指在排序过程中，待排序的所有记录全部被放置在内存中进行排序。这种排序方式适用于数据量较小，可以完全加载到内存中的情况。内部排序算法种类繁多，如快速排序、堆排序、归并排序、插入排序等。这些算法在内存中通过比较和交换记录的位置来实现排序。

**外部排序**：
外部排序则是指待排序的记录数量很大，无法全部加载到内存中，而只能分块处理，并在内存和外部存储器（如磁盘）之间进行多次数据交换的排序方式。外部排序通常用于处理大数据量的文件排序问题。由于内存容量的限制，外部排序算法需要将文件分块，对每块分别进行内部排序，然后再通过归并等策略将已排序的块合并成一个完整的有序文件。外部排序最常用的算法是多路归并排序。



当数据量非常大，以至于无法全部放入内存时，这些算法也可以被适应性地修改为外部排序版本



排序总结

比较类排序: 通过比较来决定元素间的相对次序 由于其时间复杂度不能突破 O(nlogn) 因此也称为非线性时间比较类排序
非比较类排序: 不通过比较来决定元素间的相对次序 它可以突破基于比较排序的时间下界以线性时间运行因此也称为线性时间非比较类排序

比较类排序: 交换排序 插入排序 选择排序 归并排序 而 交换排序: 冒泡排序 快速排序 插入排序: 简单插入排序 希尔排序 选择排序: 简单选择排序 堆排序 归并排序: 二路归并排序 多路归并排序

非比较类排序: 计数排序 桶排序 基数排序

**冒泡排序**

- 原理: 通过重复遍历待排序序列 比较相邻元素的值 如果顺序错误则交换它们直到没有需要交换的元素为止
- 最坏时间复杂度：O(n^2) 平均时间复杂度: O(n^2)  最好时间复杂度: O(n) 空间复杂度 O(1) 稳定排序 不占用额外内存 内部排序

**快速排序**

- 原理: 选择一个基准元素 通过一趟排序将待排序序列分割成两部分 一部分小于基准元素 另一部分大于基准元素 然后递归地对这两部分进行排序
- 最坏时间复杂度：O(n^2) 平均时间复杂度: O(nlog~2~n)  最好时间复杂度: O(nlog~2~n) 空间复杂度 O(nlog~2~n) 不稳定排序 不占用额外内存 可以外部排序

**简单插入排序**

- 原理: 将待排序序列中的元素逐个插入到已排序序列的适当位置
- 最坏时间复杂度：O(n^2) 平均时间复杂度: O(n^2)  最好时间复杂度: O(n) 空间复杂度 O(1) 稳定排序 内部排序

**希尔排序**

- 原理: 是插入排序的一种优化版本通过先对序列进行大步长的分组插入排序再逐渐减小步长进行更细致的排序最终得到有序序列
- 时间复杂度: 最坏时间复杂度：O(n^2) 平均时间复杂度: O(n^1.3)   最好时间复杂度: O(n) 空间复杂度 O(1) 不稳定 不占用额外内存 内部排序

**选择排序**

- **原理**：重复从未排序部分选出最小（或最大）元素，放到已排序部分末尾（或开头）。
- 时间复杂度: 最坏时间复杂度：O(n^2) 平均时间复杂度: O(n^2)   最好时间复杂度: O(n^2) 空间复杂度 O(1) 不稳定 不占用额外内存 内部排序

**堆排序**

- **原理**：利用二叉堆（大顶堆或小顶堆）结构，逐步将最大（或最小）元素移到序列末端，并调整剩余元素维持堆性质。
- 时间复杂度: 最坏时间复杂度：O(nlog~2~n) 平均时间复杂度: O(nlog~2~n)   最好时间复杂度: O(nlog~2~n) 空间复杂度 O(1) 不稳定 不占用额外内存 内部排序

**归并**：

- 将序列分成多个子序列，各自排序后合并
- 时间复杂度: 最坏时间复杂度：O(nlog~2~n) 平均时间复杂度: O(nlog~2~n)   最好时间复杂度: O(nlog~2~n) 空间复杂度 O(n) 稳定 占用额外内存 可以外部排序

**计数排序**

- 原理：通过统计每个元素出现的次数，然后根据次数信息确定元素的相对顺序。
- 时间复杂度: 最坏时间复杂度：O(n+k) 平均时间复杂度: O(n+k)  最好时间复杂度: O(n+k)  空间复杂度 O(n+k)  稳定 占用额外内存 外部排序

**桶排序**

- 原理：将待排序序列的元素分配到若干个桶中，每个桶内的元素具有相同的属性（如范围、模数等），然后对每个桶内的元素进行排序（可以使用其他排序算法），最后将所有桶内的元素合并成一个有序序列。
- 时间复杂度: 最坏时间复杂度：O(n^2)  平均时间复杂度: O(n+k) 最好时间复杂度: O(n) 空间复杂度 O(n+k) 稳定 占用额外内存 外部排序

**基数排序**

- 原理：通过逐位比较元素的每一位数字（或其他字符），从最低有效位到最高有效位依次进行排序。
- 时间复杂度: 最坏时间复杂度：O(n * k) 平均时间复杂度: O(n * k)  最好时间复杂度: O(n * k) 空间复杂度 O(n+k) 稳定 占用额外内存 外部排序









# 合并有序数组

```c
void mergeOrderArr(int* arr1, int size1, int* arr2, int size2, int* mergedArr) {
    int i = 0, j = 0, k = 0;

    // 双指针技术合并数组
    while (i < size1 && j < size2) {
        if (arr1[i] <= arr2[j]) {
            mergedArr[k++] = arr1[i++];
        } else {
            mergedArr[k++] = arr2[j++];
        }
    }

    // 如果有剩余的元素则复制到合并后的数组中
    while (i < size1) {
        mergedArr[k++] = arr1[i++];
    }
    while (j < size2) {
        mergedArr[k++] = arr2[j++];
    }
}
```



# 合并有序链表

```c
LinkNode *mergeOrderLinklist(LinkNode *p, LinkNode *q) {
    LinkNode tentative;
    LinkNode *tail = &tentative;
    tentative.next = NULL;

    // 对于有头链表
    p = p->next;
    q = q->next;

    while (p != NULL && q != NULL) {
        if (p->data <= q->data) {
            tail->next = p;
            p = p->next;
        } else {
            tail->next = q;
            q = q->next;
        }
        tail = tail->next;
    }

    tail->next = (p != NULL) ? p : q;

    return tentative.next;
}
```

注意 主函数释放的时候 不必释放原链表只需要释放返回的链表 即释放一个又一个申请的节点 避免重复释放



# 0 1 2 3

插入位置 posi = 1 则 插入下标 posi - 1 = 0 最后元素位置 size = 4 最后元素下标 size - 1 = 3 插入时候移动元素个数 = 插入位置后面元素个数 + 1 插入位置后面元素个数 = 最后元素位置 - 插入元素位置

删除位置 posi = 1 则 删除下标 posi - 1 = 0 最后元素位置 size = 4 最后元素下标 size - 1 = 3 删除时候移动元素个数 = 删除位置后面元素个数 即 覆盖 删除位置后面元素个数 = 最后元素位置 - 删除元素位置



# KMP

KMP算法通过预处理模式串，构建一个部分匹配表（也称为失配函数或next数组），然后利用该表进行模式匹配。具体过程如下：

1. **预处理阶段**：计算模式串的next数组。next数组记录了模式串中每个位置的字符之前（不包括该字符本身），最长的相同前缀后缀的长度。这个长度决定了在匹配失败时，模式串应该滑动多少位。
2. **匹配阶段**：使用next数组进行匹配。在匹配过程中，当发现主串和模式串的某个字符不匹配时，根据next数组的值，直接跳转到模式串的下一个可能匹配的位置，继续进行比较，而无需像Brute-Force算法那样每次只移动一位。

- **时间复杂度**：KMP算法的时间复杂度为O(m+n)，其中m和n分别是模式串和主串的长度。这远低于Brute-Force算法的O(m*n)时间复杂度。
- **空间复杂度**：KMP算法需要额外的空间来存储next数组，因此其空间复杂度为O(m)。
- **效率**：由于KMP算法能够利用匹配失败后的信息，减少不必要的匹配次数，因此在实际应用中具有很高的效率。



```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int *initNext(char *pattern) {
    int patternSize = strlen(pattern);

    if (!patternSize) {
        fprintf(stderr, "string is null!\n");
        return NULL;
    }

    int *next = NULL;
    do {
        next = (int *) malloc(sizeof(int) * patternSize);
    } while (!next);

    int i = 1, j = 0; // i 模式字符串的后缀 从位置 1 开始依次为 next 数组进行赋值 j 模式字符串的前缀
    next[0] = 0;
    while (i < patternSize) { // init remaining next!
        if (pattern[i] == pattern[j]) {
            next[i] = j + 1;
            ++i;
            ++j;
        } else {
            if (j > 0) {
                j = next[j - 1];
            } else {
                next[i] = 0;
            }
            ++i;
        }
    }

    return next;
}

int kmp(char *text, char *pattern) {
    int textSize = strlen(text);
    int *next = initNext(pattern);
    if (!next) { return -1; }
    int i = 0, j = 0;
    while (i < textSize) {
        if (text[i] == pattern[j]) {
            ++i;
            ++j;
        } else {
            if (j > 0) {
                j = next[j - 1];
            } else {
                ++i;
            }
        }

        if (j == strlen(pattern)) {
            free(next);
            return i - strlen(pattern) + 1;
        }
    }
    free(next);
    return -1;
}


int main(int argc, const char *argv[]) {
    char *text = "AAAAAAAAAAABABC";
    char *pattern = "ABABC";

    int i = kmp(text, pattern);
    printf("%d ", i);

    return 0;
}
```









# IO

IO 定义：针对于文件的相关操作 打开文件 读取文件 写入文件 关闭文件

IO 分类

- 文件 I0: 文件 IO 指的是通过操作系统提供的系统调用接口 对文件进行读取 写入等操作 它直接操作文件描述符 是底层设备相关的开发方式 无缓冲区文件 IO 的读写操作是即时的没有中间的缓冲区来存储数据性能更好 文件描述符 通过文件描述符来识别和操作文件 系统调用 文件 IO 是基于操作系统内核的函数接口因此它是系统调用的一部分 通常用于底层设备相关的开发 如驱动程序 操作系统内核等 在这些场景中需要直接操作文件描述符以实现对设备的精确控制
- 标准 IO: 对系统调用的封装 标准 C 库里面针对于文件的相关操作它提供了一个更高级别的接口用于处理文件的输入输出操作 有缓冲区 默认大小 1024 字节 标准 IO 在读写数据时会先将数据存储在缓冲区中然后再一次性写入或读取文件减少系统调用次数提高整体性能但也可能导致数据在缓冲区中滞留 流 FILE 标准 IO 使用 FILE 结构体来表示打开的文件并围绕这个结构体进行所有的操作 跨平台性 标准 IO 是 ANSIC 标准定义的因此具有较好的跨平台性



系统调用 和 库函数

​		库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核提供给用户的程序接口，运行在内核空间中，而且许多的库函数都会使用系统调用实现功能，如在linux下c中的fopen、fclose、fwrite等文件操作函数其底层就是通过open、close、write等系统调用是实现的。没有使用系统调用的库函数，执行效率通常比系统调用高。因为使用系统调用时，需要通过中断进行上下文的切换以及由用户态向内核态的转移。不直接使用系统调用的原因是系统调用接口很简单，无法满足程序需求，并且不同操作系统的系统调用接口不兼容，程序移植时工作量大。

1.系统调用
（1）用户空间进程访问内核的接口
（2）把用户从底层的硬件编程中解放出来
（3）极大的提高了系统的安全性
（4）使用户程序具有可移植性
2．库函数
（1）库函数为了实现某个功能而封装起来的API集合
（2）提供统一的编程接口，更加便于应用程序的移植



用户态和内核态是操作系统中的两种基本运行状态，它们各自具有不同的特点和权限。以下是关于用户态和内核态的详细定义：

### 用户态

1. **定义**：用户态是指普通应用程序运行的状态。在这种状态下，应用程序只能访问有限的资源，并通过系统调用向操作系统请求服务。
2. **权限**：在用户态下，应用程序的权限受到严格限制，不能执行特权指令，也不能直接访问操作系统的数据和程序。每个进程都在各自的用户空间中运行，而不允许存取其他程序的用户空间。
3. **地址空间**：用户态通常只能操作0~3G范围的低位虚拟空间地址。
4. **应用场景**：用户态是应用程序正常运行的常态，它确保了系统的安全性和稳定性，防止应用程序对系统资源的滥用和破坏。

### 内核态

1. **定义**：内核态，也称管态、和心态，是指操作系统运行在特权模式下的状态。在这种模式下，操作系统具有对硬件的完全访问权，可以执行机器能够运行的任何指令。
2. **权限**：在内核态下，操作系统拥有最高权限，可以访问系统的所有资源，包括内存、CPU、硬件设备等。
3. **功能**：操作系统在内核态下可以执行特权指令，如停止处理器、改变模式位、发起I/O操作等。此外，系统调用、中断处理、异常处理等关键任务也都在内核态下完成。
4. **地址空间**：内核态可以操作04G范围的虚拟空间地址，尤其是对34G范围的高位虚拟空间地址必须由内核态去操作。这部分地址空间是共享的，存放着整个内核的代码和所有的内核模块，以及内核所维护的数据。
5. **应用场景**：内核态主要用于处理系统调用、中断、异常等关键任务，以及执行特权指令。它是操作系统与硬件之间交互的桥梁，确保了系统的正常运行和高效管理。

### 用户态与内核态的交互

1. **系统调用**：用户态的应用程序通过系统调用请求内核提供服务或执行操作。系统调用是用户态切换到内核态的一种主要方式。
2. **中断和异常**：当CPU在执行运行在用户态下的程序时，如果发生了某些事先不可知的异常（如缺页异常），或外围设备完成用户请求的操作后发出中断信号，这时会触发由当前运行进程切换到处理此异常或中断的内核相关程序中，也就转到了内核态。





全缓存

行缓存 只有当输出的对象是终端的时候美才会有行缓存的概念 while(1)



FILE* 指针,文件流指针，FILE是一个结构体，每打开一个文件，内核 就会开辟出一块空间，用来保存打开这个文件得到相关信息




当读取到文件的尾巴的时候，返回值是EOF也就是-1



linux系统里有一个全局变量，érrno用来保存错误信息编号，错误输出信息的打印根据错误编号而来



gets考点
1、如何判断是否读取到文件末尾？fgets返回值==NULL时说明读取到了文件的末尾
2、当读取的size（最多一次能读取的字符数）小于一行的大小时，能读取size-1个字符要给"\0'留空间



ctrl + c 软中断 提前结束程序



1、返回值是实际读取的块数 对象数记录数 和实际写入的块数对象数记录数不能说是实际的字节数
2、fread返回值〉0说明读取到数据
3、linux文件分两种
(1)文本文件 可以用记事本打开 是有效字符.c.h
（2)二进制文件 不可以用记事本打开 乱码 a.out.bmp .jpg
fgetc fgets 只能读取文本文件
fread 既能读取文本文件 也能读取二进制文件



没写入就读取风险 写入文件时数据首先被放入一个内部缓冲区中 这个缓冲区会在满足某些条件时被刷新到文件中 条件包括 缓冲区满了 显式调用 fflush 关闭文件 fclose 会隐式地刷新缓冲区 为了确保代码能够按预期工作 无论在任何平台或 C 库实现上 都应该在写入后读取之前调用 fflush 这样做可以确保所有写入操作都被执行数据已经存在于文件中 然而在实践中很多 C 库实现和操作系统都会优化这种情况它们可能允许在同一文件流上的写入后立即读取而不需要显式刷新 但是这种行为并不是 C 标准所保证的因此编写可移植代码时应该避免依赖它

```c
int main(int argc, const char *argv[]) {

    FILE *fp = fopen("../1.txt", "w+");

    if (!fp) { return -1; }

    fputc('X', fp);
    fputc('I', fp);
    fputc('A', fp);
    fputc('O', fp);

    fflush(fp);

    fseek(fp, 0, SEEK_SET);


    char c = 0;
    while ((c = fgetc(fp)) != EOF) {
        printf("%c", c);
    }
    printf("%ld", ftell(fp));

    fclose(fp);

    return 0;
}
```





复制普通文件

```c
int main(int argc, const char *argv[]) {

    if (argc != 3) { return -1; }

    FILE *fp1 = fopen(argv[1], "r+");
    FILE *fp2 = fopen(argv[2], "w");

    if (!fp1 || !fp2) { return -1; }

    while (1) {
        char c = fgetc(fp1);
        if (c == EOF) {
            break;
        }
        fputc(c, fp2);
    }

    fclose(fp1);
    fclose(fp2);

    return 0;
}
```



```c
int main(int argc, const char *argv[]) {

    if (argc != 3) { return -1; }

    FILE *fp1 = fopen(argv[1], "r+");
    FILE *fp2 = fopen(argv[2], "w");

    if (!fp1 || !fp2) { return -1; }

    char buf[128] = {0};
    while (fgets(buf, sizeof(buf), fp1)) {
		fputs(buf, fp2);
    }

    fclose(fp1);
    fclose(fp2);

    return 0;
}
```



```c
int main(int argc, const char *argv[]) {

    if (argc != 3) { return -1; }

    FILE *fp1 = fopen(argv[1], "r+");
    FILE *fp2 = fopen(argv[2], "w");

    if (!fp1 || !fp2) { return -1; }

    char buf[128] = {0};
    size_t s = 0;
    while ((s = fread(buf, 1, sizeof(buf), fp1)) > 0) {
        fwrite(buf, 1, s, fp2);
    }

    fclose(fp1);
    fclose(fp2);

    return 0;
}
```

统计行数

```c
int main(int argc, const char *argv[]) {

    if (argc != 2) { return -1; }

    FILE *fp = fopen(argv[1], "r");
    if (!fp) { return -1; }

    int cnt = 1;
	char c = 0;
    while ((c = fgetc(fp)) != EOF) {
        if (c == '\n') {
        	++cnt;
        }
    }
    printf("%d", cnt);

    return 0;
}
```





```c
int main(int argc, const char *argv[]) {

    if (argc != 2) { return -1; }

    FILE *fp = fopen(argv[1], "r");
    if (!fp) { return -1; }

    int cnt = 1;
    char buf[128] = {0};
    while (fgets(buf, 128, fp)) {
        if (buf[strlen(buf) - 1] == '\n') {
        	++cnt;
        }
    }
    printf("%d", cnt);

    return 0;
}
```





```c
int main(int argc, const char *argv[]) {

    FILE *fp1 = fopen("../1.txt", "r+");
    
    if (!fp1) { return -1; }

    char buf[50] = {0};
    int len = 0;
    while ((len = (fread(buf, 1, 49, fp1))) > 0) {
        buf[len] = 0;
        printf("%s", buf);
    }

    fclose(fp1);

    return 0;
}
```





流是标准IO核心的操作对象
一个程序开始执行后会自动打开三个流
标准输入流stdin默认从键盘输入
标准输出流stdout 默认向终端输出
标准错误输出流stderr默认向终端输出

标准输出流存在缓存区标准错误输出流不存在缓存区







文件 IO

open

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);



//打开文件的方式如下
O_RDONLY//以只读的方式打开 RDread ONLY
O_WRONLY//以只写的方式打开 wR writeONLY
O_RDWR//以可读可写的方式打开
O_TRUNC//清空原文件中的内容
O_APPEND//追加文件尾巴
O_CREAT//创建文件
mode_t mode//文件权限
如果当第二个参数flag有O_CREAT，可以加上第三个参数代表文件权限I0666



constchar*pathname／/打开文件的文件名（可以相对路径也可以是绝对路径)
int flags／/打开文件的方式

返回值：
成功：
int fd//非负  文件描述符  ，每打开一个文件，内核就会自动给应用进程返回一个文件描述符，做为该打开文
件的标识I
失败：
-1

epoll

intfd=open（"hello.c",o_wRoNLY);//以只写的方式打开
int fd =Open（"he1lo.c",O_wRONLY丨o_TRUNc丨o_CREAT，0666）;//以只写的方式打开hello.C，
//如果hello.c存在清空并打开，如果不存在创建并打开





close

功能：
关闭文件
(2)头文件及函数原型
#include <unistd.h>
int close(int fd);
7/调用参考
close(fd);
（3）参数说明
int fd;//open函数返回值，被关闭的文件描述符
（4）返回值
成功：0
失败：-1



read

文件及函数原型
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);

参数说明：
int fd//文件描述符，open的返回值
void*buf//文件中读取出数据的存储位置
size_t count//最大读取的字节数
//调用
charbuf[100]={0}；//用来存储读取的数据
read(fd,buf,sizeof(buf));
(4)返回值：
成功;
实际读取到的字节数
read返回值：成功实际读取到的字节数
失败：-1



write

头文件及函数原型
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
（3）参数说明：
int fd //文件描述符，open的返回值
constvoid*buf／/指向将要写入文件中数据的存储位置
size_t count //实际 你想要 写入的字节数
//调用参考
charrbuf[100］="hello"；//用来存储读取的数据
write(fd,buf,strlen(buf))；//strlen(buf)代表实际写入的字节数 sizeof(buf） == 100
（4）返回值：
成功：
实际写入的字节数
失败：-1



lseek

lseek函数 兼具了fseek和ftell两个函数的功能
(1)功能:
移动文件指针，同时能够获取移动之后文件指针的位置
(2)头文件及函数原型
typedef longoff_t;
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
(3)参数说明：
intfd//open的返回值
off_t offset//偏移量
intwhence//基准值，相对位置
//偏移量：正数--->向后移动负数---->向前移动
lseek(fd,100,SEEK_SET)；//相对文件起始位置向后移动100个字符
lseek（fd，-100,SEEK_END)；//相对于文件尾位置向前移动100个字符
lseek（fd,100,SEEK_cUR）；//相对于当前文件指针的位置向后移动100个字符
1seek（fd，-100,SEEK_cUR)；//相对于当前文件指针的位置向前移动100个字符

返回值：
成功：返回移动完文件指针之后，当前文件指针的位置
失败 -1



LinuxIo操作的核心对象是文件描述符
一个程序的执行有三个自动打开的文件描述符
标准输入0默认从键盘输入
标准输出1默认从终端输出
标准错误输出2默认从终端输出



(1)功能:
获取文件属性的
(2)头文件及函数原型
#include <unistd.h>
int stat(const char *path, struct stat *buf);
(3)参数说明：
constchar*path//将要获取属性的文件名，可以加上路径修饰
struct stat*buf//用来保存这个文件属性信息的一个结构体
//调用参考
structstats={o}；//所有的成员变量都是0
stat（"hello.c",&s）;//参数上的地址传递
//函数调用结束之后s变量里面，存储的就是hello.c的文件属性
stat（"/home/1inux",&s）；//获取目录文件1inux这个文件夹的属性

返回值：成功：返回：0失败：返回：-1

```c
struct stat {
mode_tst_mode;//文件对应的模式，文件，目录等
ino_tst_ino;//inode节点号
dev_tst_dev;//设备号码
dev_tst_rdev;//特殊设备号码
nlink_tst_nlink;//文件的连接数
uid_tst_uid;//文件所有者
gid_tst_gid;//文件所有者对应的组
off_tst_size;//普通文件，对应的文件字节数
time_tst_atime;//文件最后被访问的时间
time_tst_mtime;//文件内容最后被修改的时间
time_tst_ctime;//文件状态改变时间
blksize_t st_blksize;//文件内容对应的块大小
blkcnt_tst_blocks;//文件内容对应的块数量
}:
```



opendir
(1)功能：
打开目录文件directory
(2)头文件及函数原型
#include <dirent.h>
DIR *opendir(const char *name);
(3)参数说明：
constchar*name//目录文件名（可以相对路径也可以是绝对路径）
//调用参考
DIR* dp = opendirC"/home/linux/240751o");
(4)返回值：
成功：
DIR *//成功，返回非空的打开目录文件的标识
失败：
NULL





readdir
（1）功能：读取目录文件，每次读取出一个文件
（2）头文什及函数原
#include <dirent.h>
struct dirent *readdir(oIR dirp);
（3）参数说明：
DIR *dirp//opendir的返网值
/钢用
struct dirent* ep = readdir(dp);
printf("%s\n",ep=>d_name) ;
（4）返网值：
成功：
structdirent//川案保存从口录文f中读取文的结构体指针structdirent
失败：
返日NULL//口录文的所有文付都读取完毕
#include <dirent.h>
struct dirent
long d_ino;/*inodenumber紫引l节点号*/
off_t d_off;/*offset tothis dirent 在目录文作中的偿移 */
unsigned short d_reclen; /* length of this d_nane 文f名长 */
unsigned char d_type;/* the type of d_nane 文件类型 */
char d_name[NAME_MAx+1]: /α file name (nu1l-terminated)）文件名，最长255字符/



3.closedir函数
closedir
（1）功能：美闭目录文件
（2）头文件及丽数原型
#include cdirent.h>
int closedir(orR *dirp) ;
//调用
closedir(dp);
（3）参数说明：
DIR *dirp//opendir的返回值
（4）返国值：
虚功：0
失败：-1









```c
int main(int argc, const char *argv[]) {

    int fd = open("../1.txt", O_RDONLY | O_CREAT, 0666);
    if (fd == -1) { return -1; }

    printf("%d", fd);  //-- 3

    close(fd);

    return 0;
}
```



```c
int main(int argc, const char *argv[]) {

    int fd = open("../1.txt", O_RDONLY | O_CREAT, 0666);
    if (fd == -1) { return -1; }

    char buf[32] = {0};
    int ret = 0;
    while((ret = read(fd, buf, sizeof(buf) - 1)) > 0){
        buf[ret] = 0;
        printf("%s", buf);
    }

    close(fd);

    return 0;
}
```



```c
int main(int argc, const char *argv[]) {

    int fd1 = open("../1.txt", O_RDONLY);
    int fd2 = open("../2.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);

    if (fd1 == -1 || fd2 == -1) { return -1; }

    char buf[32] = {0};

    int ret = 0;
    while ((ret = read(fd1, buf, sizeof(buf))) > 0) {
        write(fd2, buf, ret);
    }

    close(fd1);
    close(fd2);

    return 0;
}
```







date



structtm是c语言中的一个结构体，定义在头文件<time.h>中。它用于存储时间和日期的信息，以
便程序可以更方便地操作和处理时间。结构体的定义如下

struct tm{
int tm_sec;//秒，范围从0到59
int tm_min;//分，范围从0到59
int tm_hour;//时，范围从0到23
int tm_mday;7/一个月中的日，范围从1到31
int tm_mon;//月份，范围从0到11
int tm_year;7/年份，从1900开始
int tm_wday;II/一周中的日，范围从0（周日）到6（周六)
int tm_yday;一年中的日，范围从0到365
int tm_isdst；//夏令时标识
};

获取系统时间需要使用到的函数
time函数7/获取距今的秒数
ctime函数//将距今的秒数转换为英文格式的系统时间
1ocaltime//将距今的秒数转换为中文格式的系统时间

```c
#include "IO.h"
#include <time.h>

int getLine(FILE *fp) {
    char c = 0;
    int cnt = 1;
    while ((c = fgetc(fp)) != EOF) {
        if (c == '\n') { ++cnt; }
    }
    return cnt;
}

void writeDate(FILE *fp, int i) {
    while (1) {
        time_t date = 0;
        time(&date);
        struct tm *info = NULL;
        info = localtime(&date);


        fprintf(fp, "%d. %d-%d-%d %d:%d:%d\n",
                i,
                info->tm_year + 1900, info->tm_mon + 1, info->tm_mday,
                info->tm_hour, info->tm_min, info->tm_sec);
        ++i;
        fflush(fp);

        sleep(1);
    }
}

int main(int argc, const char *argv[]) {
    FILE *fp = fopen("./2.txt", "a+");
    if (!fp) { return -1; }

    int i = getLine(fp);

    writeDate(fp, i);

    fclose(fp);

    return 0;
}
```











# 进程 线程 进程通信

linux下的多任务机制
//linux系统的特点：多任务、多用户、良好的可移植性
(1)多任务处理
多任务处理是指用户在同一时间内可以运行多个任务，每个正在执行的一个应用程序被称为一个任务
(2)任务的执行
一次任务的执行，可以进发激活多个进程，这些进程互相合作来完成这个终极目标
(3)多任务执行的本质
处理器在某一时刻只能执行一个任务，每个任务创建时会被分配时间片。任务执行（占用时间片），时间片递减，操
作系统的时间片用完时调度执行其他的任务，频繁切换并且时间非常短，给用户的感觉像是多个任务在同时运行



(1)进程是一个程序在一个数据集上执行一次的过程
//程序=数据结构+算法
//进程实体：代码段+数据+PCB（processcontonr］block进程控制块)
//pcb是进程存在的唯一标识
//pcb：进程资源信息进程控制信息CPU现场信息进程标志信息
(2)进程是一个 独立的可调度的 任务
(3)进程是操作系统进行 资源分配 的最小单位 线程是操作系统进行调度的最小单位

4)进程和程序的区别(重点面试问题)
//本质区别：进程是动态的程序是静态的
//进程是一个程序在一个数据集上执行一次的过程 程序是保存在磁盘上有序指令的集合（程序控制的最小单位：指
令)
//程序是永存的而进程是暂时性的随着创建而产生调度而运行销毁而消亡
//进程具有并发性 程序没有
//进程是操作系统进行 资源分配的最小单位 程序不是
//进程和程序不是一一对应的」一个进程可以对应多个程序一个程序也可以对应多个进程

(5)进程特点
并发性：系统中多个进程可以同时并发执行，互不干扰
动态性：进程有完整生命周期，在生命周期内进程状态不断变化
交互性：进程执行过程中可能与其他进程进行直接或者间接通信
独立性：进程是计算机资源分配和调度的基本单位 各进程的地址空间是相互独立的
(6)进程分类
交互式进程：经常与用户交互的进程，需要等待用户输入（vi编辑器)
批处理进程：不必与用户进行交互 (编译器编译工作)
守护进程：一直在后台运行的进行，和任何终端不联系，启动就执行，关闭即结束（windows系统中的服务）



进程状态模型

进程的三个基本状态：运行态、就绪态、阻塞态
进程状态的详细划分：
(1)运行态
(2)阻塞态
(3)暂停态ctrI＋ z //会将前台进程放入到后台，处于暂停状态
(4)僵死态 僵尸进程，此时的状态就是僵死态
(5)消亡态 最终状态
(6)就绪态



(1)头文件及函数原型
#include <unistd.h>
pid_t fork(void);
typedef int pid_t;
(2)功能
用于创建一个子进程，当执行完fork 就会出现一个新进程(新进程称为子进程，原来的进程称为父进程)
fork执行完 子进程会几乎 复制父进程所有东西，并且子进程从fork后面语句开始执行

父进程保存子进程PID



在Linux系统中，`fork()`函数用于创建一个新的进程，称为子进程。这个函数的特点是其调用一次但会返回两次值：一次是在父进程中，另一次是在子进程中。具体返回值如下：

1. **父进程中**：`fork()`函数返回新创建的子进程的进程ID（PID）。这是一个大于0的整数。
2. **子进程中**：`fork()`函数返回0。

如果`fork()`函数调用失败，则会在父进程中返回-1，此时不会创建新的子进程。

以下是一个简单的示例程序，展示了如何使用`fork()`函数并处理其返回值：







当父进程创建完子进程后父子进程谁先执行要看操作系统采用什么调度算法

在上面示例程序中父进程先执行 所以父进程先结束此时子进程还没结束此时的子进程叫做孤儿进程 会被init进程接管init进程（pid==1）变成它的父进
程 并且子进程会放在后台执行 不受终端控制





```c
int main(){
    for(int i = 0; i < 3; ++i){
        fork();
    }
    puts("XIAOYU");
}

|--|--|--|
   	--|
 --|--|
 --|
```





exit函数
(1）功能：
用于结束进程，当程序执行到exit函数时，进程立刻结束，但在结束进程之前会刷新缓存区
(2)头文件与函数原型
#include <stdlib.h>
void exit(int status);
(3)参数：
intstatus是一个整型的参数，可以利用这个参数传递进程结束时状态。一般来说，0表示正常结束，
其它值表示出现了错误，当程序执行到exit函数时，就结束进程，但在结束进程前会刷新缓存区
exit(O)；//0正常结束执行exit()函数后，会刷新缓存区，将缓存区中的内容写入到文件中，再结束进程
exit（-1)；//-1异常结束执行exit（)函数后，会刷新缓存区，将缓存区中的内容写入到文件中，再结束进程



_ exit函数
（1）功能:
用于结束进程，当程序执行到_exit函数时，进程立刻结束,不会刷新缓存区
(2)头文件与函数原型
#include <stdlib.h>
void _exit(int status);
(3)参数
int status是一个整型的参数，可以利用这个参数传递进程结束时的状态。一般来说，O表示正常结束,
其它值表示出现了错误，当程序执行到exit函数时，结束进程
_exit(O)；／/0正常结束执行_exit()函数后，不会刷新缓存区，直接结束进程
_exit（-1)；//-l 异常结束 执行_exit()函数后，不会刷新缓存区，直接结束进程



孤儿进程 子进程未结束父进程先结束此时的子进程会被init进程所接管并且放入后台运行此时的子进程称为孤儿进程

僵尸进程 子进程先结束 父进程未结束 父进程没有调用wait族函数及时挥回收子进程的资源 PID 此时子进程就是僵尸进程



父进程座该晚于子进程结束，父进程调用wait族函数，来回收子进程的资源
wait函数：阻塞等待子进程结束一旦子进程结束立刻回收资源并接解除阻塞
waitpid函数：等待某一个子进程结束结束，一旦那个子进程结束立刻回收资源可以阻塞也可以非阻塞



wait函数
(1)功能：
wait(当父进程执行此函数时，父进程阻塞等待子进程结束)
父进程执行到wait函数就会阻塞，等待子进程的结束，一旦有一个子进程结束，wait将结束阻塞
当子进程结束时，父进程会通过wait函数回收子进程的资源
(2)头文件及函数原型
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
I
//调用参考
wait(NULL) 

ints;//s里面是随机数
//当想要获取子进程结束时的状态的时候，需要通过参数上地址传递的方式，来获取
wait（&s）；//调用函数之后，s里面不是随机数了，保存的是子进程结束时的状态
(3)函数参数
status是一个整型指针，指向的对象用来保存子进程退出时的状态。
status若为空，表示忽略子进程退出时的状态，通常赋值为NULL
status若不为空，表示保存子进程退出时的状态
返回值
成功：
pid_t//返回值是结束的那个子进程的PID
失败：-1



aitpid函数
(1)功能：指定等待某个子进程的结束
（2）头文件及函数原型：
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);//等待指定的子进程结束
waitpid(1122，NULL，0)；//第三个参数是0，阻塞等待PID是1122这个子进程的结束，回收资源
waitpid（1133，NULL，WNOHANG）；//第三个参数WNOHANG非阻塞回收PID是1133这个进程资源
//第三个参数是WNOHANG，如果子进程没有结束，waitpid函数的返回值一直是0
//当子进程结束的时候，waitpid函数的返回值就是结束的那个子进程的PID
(3)参数说明：
pid_t pid //pid >0 回收进程的ID
//pid =-1 回收任何一个子进程此时作用和wait一样
//pid=O回收其组ID等于调用进程的组ID的任一子进程
//pid<-1回收其组ID等于pid的绝对值的任一子进程

int*status//同wait函数的参数
intoptions:

wNOHANG表示不阻塞，waitpid不阻塞而立即返回，此时值为O，结束后返回值为结束子进程pid
0阻塞
(4)返回值：

0：已经结束运行的子进程进程号
0:使用WNOHANG且没有子进程退出
-1：出错



exec族函数
什么时候我们想到用exec族函数？？？
当想要在当前的程序中去调用另外一个程序的时候，使用exec族函数
executee//执行什么时候我们想到用exec族函数？？？
当想要在当前的程序中去调用另外一个程序的时候，使用exec族函数
executee//执行

通过调用下面的exec族函数可以执行另一个程序
(1)功能：
用fork函数创建子进程后，子进程往往要调用一种exec函数以执行另一个程序。
当进程调用一种exec函数时，该进程全由新程序代换，而新程序则从其main函数开始执行。
因为调用exec并不创建新进程，所以前后的进程PID并未改变。exec只是用另一个新程序替换了
当前进程的正文、数据、堆和栈段
(2)头文件及函数原型
#include <unistd.h>
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg,...）；//...表示多个参数
int execle(const char *path, const char *arg

1//1ist缩写希望接收以逗号分隔的参数列表，列表以NULL作为结尾标志
P//PATH系统会按照PATH环境变量进行路径进行查找命令
e//enviroment缩写指定当前进程所使用的环境变量
V//vertor缩写参数传递为以NULL结尾的宝符指针数组



Linux中的两类进程
1、前台进程运行在终端上终端关闭进程也随之结束
2、后台进程不运行在终端在后台运行不受终端控制

守护进程
守护进程，也就是通常所说的Daemon进程，是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终
端并且圃期性的执行某种任务或等待处理某些发生的事件，守护进程常常在系统启动时开始运行，在系统关闭时终止Linux
系统有很多守护进程，大多数服务都是用守护进程实现的
守护进程能够突破这种限制，它从开始运行，直到整个系统关闭才会退出。
//如果想让某个进程不会因为用户或终端的变化而受到影响，就必须把这个进程变成一个守护进程。



ps ajx 查看守护进程

umask命令
//用open创建新文件是赋予权限0666创建以后发现权限是0664查看文件权限掩码是0002
umask 命令
功能：查看当前系统的文件权限掩码
文件权限掩码的作用：二进制位是1，掩盖权限，二进制位是0，不掩盖



umask 0666 改变文件权限掩码 默认 0002



如何编写守护进程（重点，教材p62-65）
(1)创建一个子进程，结束父进程 （让其成为孤儿进程)
(2)子进程创建新会话(setsid()函数)
(3)修改进程当前目录（chdir（"/tmp"))//不是必须的change directory
(4)重置文件权限掩码（umask(O)）
(5)关闭子进程从父进程复制过来的文件描述符
int num = getdtablesize(）；//获取文件描述符表大小
int i;
for(i = O; i < num;i++）
{
close(i);

}



线程

线程概念(p49)
为进一步减少处理器的空转时间，支持多处理器以及减少上下文切换开销，进程演化出线程，它是进程内独立的一条运行路
线，是内核调度的最小单元。
(1)线程是轻量级进程（因为进程的效率低 才引入线程)
(2)线程依附于进程（1个进程可以创建多个线程，但是1个线程只能属于一个进程，如果进程结束，那么它所创建的线程也
随之结束）／/皮之不存毛将焉附
(3)多线程只开辟栈区，所以线程的效率高



pthread_create

#include <pthread.h>
//回调函数：参数中带有函数指针的函数
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start_routine)(void *), void *arg);
(3)参数说明：
pthread_t*thread／/通过参数上地址传递的方式，获取线程的ID
const pthread_attr_t *attr //设置线程的属性，通常为NULL
void*（*start_routine）（void*）/函数指针，函数指针指向的函数，就是线程执行的功能函
//指针的类型 挡住pvoid *(*）(votd *)
//指针指向的类型 挡住*pvoid *(）(void *)
void*arg//第四个参数是为第三个参数服务，给三个参数传参用的（给线程函数传递参数用的

//调用参考
void*fun（void*p）//线程执行的函数，线程
线程执行的代码；
pthread_tid；//用来保存线程的ID
//通过参数上地址传递的方式，来获取线程的ID
pthread_create(&id,NULL, fun,NULL) ;
（4）返回值
成功：
失败：-1
//一个函数给调用者返回值一个值儿种方式：2种
//返回值参数上地址传递的方式



gcc01-创建线程.c-lpthread
加载第三方动态库libthread.so

1inux中中动态库以.so为结尾静态库库以.a为结尾





链接方式

静态连接：在编译时候找函数将函数源码从静态库复制到源文件中

动态链接：运行的时候找函数 编译的时候将函数的地址放进源文件中



静态链接和动态链接区别
可执行文件大小的角度静态链接大
从占用内存的角度静态链接大
从效率角度来说动态链接高
从升级的角度动态链接好

安装的角度静态连接好(动态链接 多个链接文件如果误删一个 则无法链接成功)



静态库：以.a为结尾在编译的时候找函数将函数源码复制进源文件运行时不需要加载动态库占用体积大
共享库（动态库)：以.so为结尾在运行的时候找函数 编译时将函数地址编译进源文件 运行的时候需要加载动态库占用
体积小
//windows和linux都是动态链接



阻塞等待一个子线程的结束
(1)功能:
用来阻塞等待指定线程结束
（2）头文件及函数原型
#include <pthread.h>
int pthread_join(pthread_t thread, void ** retval);
//调用参考
pthread_join（2345，NuLL）；//阻塞等待线程ID是2345这个线程结束，如果2345线程不结束，pthread_join
一直阻塞等待，直到2345这个线程结束，pthread_join函数才会解除阻塞
I
(3)参数说明：
pthread_t thread //阻塞等待线程结束的id
void **retval//用来保存线程结束时的返回值，通常赋值为NULL
(4)返回值：
成功：0
失败：-1



调用哪个线程取决于操作系统

```c
void *fun1(void *p){
    while (1) {
        printf("1 is running\n");
        sleep(1);
    }
}

void *fun2(void *p){
    while (1) {
        printf("2 is running\n");
        sleep(1);
    }
}

int main(int argc, const char *argv[]) {
    pthread_t id1 = 0, id2 = 0;
    int ret1 = pthread_create(&id1, NULL, fun1, NULL);
    int ret2 = pthread_create(&id2, NULL, fun2, NULL);
    if (ret1 == -1 || ret2 == -1) {
        exit(-1);
    }
    sleep(10);
    return 0;
}

1 is running
2 is running
1 is running
2 is running
2 is running
1 is running
```



互斥

互斥（Mutex）是一种用于多线程编程中的同步机制，它的主要目的是保护共享资源，防止多个线程同时访问该资源而导致数据竞争和不一致。互斥锁通常被实现为一个二进制的锁，它有两种状态：锁定（locked）和解锁（unlocked）。

### 互斥锁的工作原理

1. **锁定（Locking）**：当一个线程希望访问某个共享资源时，它会尝试获取与该资源相关联的互斥锁。如果锁当前是解锁状态，那么该线程将成功获取锁，并将其状态设置为锁定，从而确保在该线程释放锁之前，没有其他线程可以访问该资源。
2. **解锁（Unlocking）**：当线程完成对共享资源的访问后，它会释放互斥锁，将其状态设置回解锁。此时，其他等待访问该资源的线程中的一个（如果有的话）将能够获取锁并继续执行。

### 互斥锁的特性

- **互斥性**：互斥锁确保在任何时候，只有一个线程可以持有锁并访问受保护的资源。
- **原子性**：获取和释放互斥锁的操作是原子的，这意味着它们不会被其他线程的操作中断。
- **公平性**：某些互斥锁实现可能支持公平性策略，即按照线程请求锁的顺序来授予锁，以避免某些线程长时间等待。

### 使用互斥锁的注意事项

- **避免死锁**：死锁是指两个或多个线程相互等待对方释放锁，从而导致所有线程都无法继续执行的情况。为了避免死锁，程序员需要确保每个线程在持有锁的情况下最终都会释放锁，并且避免循环等待的情况。
- **性能考虑**：互斥锁的使用可能会引入额外的开销，包括上下文切换、锁竞争和等待时间等。因此，在设计并发程序时，需要权衡使用互斥锁带来的同步安全性和性能影响。
- **选择正确的锁类型**：根据应用程序的具体需求，可能需要选择不同类型的互斥锁（如递归锁、读写锁等）来优化性能和同步策略。





互斥锁（Mutex）和信号量（Semaphore）都是用于多线程编程中的同步机制，但它们在应用场景、实现方式和性能特点上有所不同。

### 互斥锁（Mutex）

互斥锁是一种用于多线程多任务互斥的同步机制。它确保同一时刻只有一个线程能访问特定的资源，防止资源被多个线程同时访问。互斥锁的值通常只能为0或1，表示资源是否被锁定。当线程尝试访问被互斥锁保护的资源时，如果锁已被其他线程持有，则当前线程将被阻塞，直到锁被释放为止。

互斥锁的优点在于其简单性和易用性。它适用于保护临界区，确保数据的一致性和完整性。然而，互斥锁也可能导致性能瓶颈，特别是在高并发环境下，因为线程在获取锁时可能会面临较长的等待时间。

### 信号量（Semaphore）

信号量则是一种更灵活的同步机制，它不仅可以用于线程间的同步，还可以用于进程间的同步。信号量的值可以是任意非负整数，这表示了可用资源的数量。当信号量的值大于0时，表示有可用资源，线程可以继续操作；当信号量的值为0时，表示没有可用资源，线程需要阻塞直到资源变得可用。

信号量的优点在于其能够控制对共享资源的并发访问数量，从而避免资源竞争和死锁等问题。它适用于实现生产者-消费者模式等复杂的同步场景。然而，信号量的使用也相对复杂，需要程序员仔细考虑资源的分配和释放策略，以避免出现资源泄露和死锁等问题。



### 区别与联系

1. **应用场景**：互斥锁主要用于保护临界区，确保同一时刻只有一个线程能访问特定的资源；而信号量则用于控制对共享资源的并发访问数量。
2. **实现方式**：互斥锁的值通常只能为0或1，表示资源是否被锁定；而信号量的值可以是任意非负整数，表示可用资源的数量。
3. **性能特点**：互斥锁在锁定资源时，所有试图访问该资源的线程都会被阻塞，直到资源被解锁；而信号量在资源被锁定时，允许其他线程继续执行某些任务，直到资源被释放。
4. **使用难度**：互斥锁的使用相对简单，适用于保护简单的临界区；而信号量的使用则相对复杂，需要程序员仔细考虑资源的分配和释放策略。



创建互斥锁
(1)头文件及函数原型
#includer <pthread .h>
int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *restrict
attr);
//调用参考
//mutex 互斥
pthread_mutex_tmutex={0}；//定义一个结构体变量mutex
pthread_mutex_init(&mutex,NULL)；//初始化互斥锁，就是结构变量初始化
(2)参数说明：
pthread_mutex_t *mutex //互斥锁
const pthread_mutexattr_t *restrict attr //互斥锁的属性，通常NuLL
(3)返回值：
成功：返回0
失败：返回错误编号



上锁

(1)头文件及函数原型
#include <pthread.h>
int pthreadl_mutex_lock(pthread_mutex_t *mutex);
//调用参考
/ /lock 锁
pthread_mutex_lock(&mutex) ;
(2)参数说明：
pthread_mutex_t *mutex//互斥锁
(3)返回值：
成功:0
失败：返回错误编号



解锁
(1)头文件及函数原型
#include <pthread.h>
int pthread_mutex_unlock(pthread_mutex_t *mutex) ;
//调用参考I
 pthread_mutex_unlock(&mutex) ;
(2)参数说明：
pthread_mutex_t *mutex//互斥锁
(3)返回值：
成功：0
失败：返回错误编号







线程的同步(重点）
1.什么是同步
在异步环境下一组并发进程 相互制约相互等待相互配合 按照一定顺序执行



如何解决线程的同步
使用信号量可以解决多线程之间的同步问题



### 使用互斥锁+条件唤醒可以解决多线程之间的同步问题





信号量是什么
可以将信号量理解成一类资源将一个信号量理解成停车场
信号量的个数就是停车场中停车位的个数

信号量作用
解决多线程之间互斥和同步问题



信号量使用方法
(1)创建信号量//初始化一个停车场
(2)请求信号量//申请一个停车位停车位个数-1
(3)释放信号量//释放一个停车位停车位个数+1不要怕



创建信号量

(1）功能：对信号量进行初始化(即对停车场的停车位的个数进行初始化)
（2）头文件及函数原型
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
(3)参数说明：
sem_t *sem //信号量(停车场)
int pshared//通常为0，表示信号量在线程之间共享
unsigned int value //停车位的个数
7/调用参考
sem_t sem={〇}；//定义一个结构体变量名字叫sem，创建一个停车场
//第二个参数0，代表多个线程之间共享这个信号量
sem_init(&sem，0，0)；//停车位数为0，用来解决多线程的同步问题
sem_init(&sem，0，1)；//停车位数为1，，类似于于互斥锁，用来解决多线程的互斥问题
(4)返回值：
成功：返回0
失败：返回-1
(2)请求信号量
(1)功能：请求信号量(即请求停车)
(2)头文件及函数原型
#include <semaphore.h>
int sem_wait(sem_t *sem);
(3)参数说明：
sem_t*sem //一但请求信号量成功，停车位-1，请求失败，阻塞等待
7/调用参考
//何时会出现请求失败？？？当停车场停车位为0的时候，请求失败
sem_wait(&sem);//信号量，一但请求信号成功，停车位-1，请求失败，阻塞等待
(4)返回值：
成功：返回0
失败：返回-1
(3)释放信号量
(1)功能：释放信号量(即停车位+1)
(2)头文件及函数原型
#include <semaphore.h>
int sem_post(sem_t *sem) ;
(3)参数说明：
sem_t*sem//释放信号量，停车位+1
//调用参考
sem_post(&sem) ;
(4)返回值：
成功：返回0
失败：返回-1



```c
sem_t sem1 = {0};
sem_t sem2 = {0};

void *fun1(void *p) {
    while (1) {
        printf("1\n");
        sem_post(&sem1);
        sleep(1);
    }
}

void *fun2(void *p) {
    while (1) {
        sem_wait(&sem1);
        printf("2\n");
        sem_post(&sem2);
    }
}

void *fun3(void *p) {
    while (1) {
        sem_wait(&sem2);
        printf("3\n");
    }
}

int main(int argc, const char *argv[]) {
    pthread_t id1 = 0, id2 = 0, id3 = 0;
    int ret1 = pthread_create(&id1, NULL, fun1, NULL);
    int ret2 = pthread_create(&id2, NULL, fun2, NULL);
    int ret3 = pthread_create(&id3, NULL, fun3, NULL);
    if (ret1 == -1 || ret2 == -1 || ret3 == -1) {
        exit(-1);
    }

    sem_init(&sem1, 0, 0);
    sem_init(&sem2, 0, 0);

    pthread_join(id1, NULL);
    pthread_join(id2, NULL);
    pthread_join(id3, NULL);

    return 0;
}
```





测试线程堆栈大小
默认情况堆栈大小（有些系统1M，有些2M，有些4M，有些8M）
如果定义一个局部变量占用空间特别大，要要改堆栈大小





修改线柱堆伐人小

功能：获取当前线程默认的属
(2)头文件及函数原型
#include <pthread.h>
int pthread_attr_init(pthread_attr-t *attr);
(3)参数
pthread_attr_t*attr//通过参数上地址传递的方式获取线程的属性
//调用参考
pthread_attr_t attr ={〇 };//用来存储默认的线程属性
pthread_attr_init(&attr）;//通过参数上地址传递的方式获取线程的属性，保存到attr变量中
(4)返回值
成功：
返回0
失败：
返回 非零的错误编号



thread_attr_setstacksize函数
(1)功能：设置当前线程的堆栈大小
(2)头文件及函数原型
#include <pthread.h>
int pthread_attr_ststacksize(pthread_attr_t *attr, size_t stacksize) ;
(3)参数
pthread_attr_t *attr//线程的属性
size_t stacksize//线程属性中的堆栈大小被设置的新的大小值以字节为单位
//调用参考
pthread_attr_setstacksize(&attr，10*1024*1024);//设置线程属性中的堆栈大小为10M
(4)返回值
成功：
返回0
失败:
返回非零的错误编号

```c
    FILE *fp = fopen("./info.txt", "w");
    if (!fp) { exit(-1); }

    time_t date = 0;
    time(&date);
    struct tm *dt = localtime(&date);
    char buf[128] = {0};
    sprintf(buf, "%d-%d-%d %d:%d:%d",
            dt->tm_year + 1900,
            dt->tm_mon + 1,
            dt->tm_mday,
            dt->tm_hour,
            dt->tm_min,
            dt->tm_sec);
    fwrite(buf, 1,strlen(buf), fp);
    fclose(fp);
```





## 进程间通信方式（重点背下来）

1、管道
2、信号
3、消息队列
4、其享内存
5、信号量
6、socket套接字

其中12是传统通信方式
345是IPC通信方式
1 2 34 5实现同一台主机间两个不同进程通信
6可以实现两台不同主机之间通信





创建无名管道
//pipe管道
（1）头文件及函数原型
#include <unistd.hF
int pipe(int pipefd[2]);//int pipe(int *pipefd);
//调用
intpipefd[2]={0}；//用来保存读端和写端的文件描述符
//pipefd[o]元素，里面保存的是读端的文件描述符
//pipefd[1]元素，里面保存的是写端的文件描述符
pipe（pipefd）；//将数红的首地址传递给pipe函数，得到无名管道读端和写端的文件描
read(pipefd[o],buf,sizeof(buf));
write(pipefd[1],buf,strlen(buf));
(2)功能：
创建一个无名管道
（3）参数说明：

返回值
成功：
失败：-1



1.2无名管道特点总结
1、无名管道只能作用于有亲缘关系的进程中使用
2、无名管道是半双工通信，有固定的读端和写端 fd[O］---读端的文件描述符 fd[1]---写端的文件描述符
3、无名管道是一个特殊的文件，不属于任何文件系统，只存在于内存中
4、无名管道中没有数据的时候 读取阻塞
5、无名管道写入的数据FIFO遵循先进先出规则
6、无名管道没有名字 在文件系统中不可见I调用pipe函数 得到读端和写端的文件描述符
7、无名管道不支持lseek移动文件指针



1．头文件及函数原型
#include <sys/types.h>
#include <sys/stat.h>
/ /mkmake
//fifo first in first out 先进先出 有名管道
int mkfifo(const char *pathname, mode_t modep:
//调用
mkfifo（"./myfifo"，0666)；//相对路径方式 在当前目录下创建一个有名管道文件，名字叫myfifo
mkfifo（"/home/linux/Public/myfifo",0666)；//绝对路径方式在Public下创建创建一个有名管道文
件，名字叫myfifo

2．功能：
创建一个有名管道
3．参数说明：
constchar*pathname//创建有名管道文件的名字（可以有相对路径或绝对路径的修饰)
mode_t mode//管道文件的访问权限 0666
4．返回值
成功:0
失败：-1



重点：
当有名管道读端存在的时候往管道中写入数据才有意义先运行读端
1.2有名管道特点总结
I
1、有名管道可以在亲缘进程和非亲缘进程间都可以使用
2、有名管道是半双工通信，有固定的读端和写端
3、有名管道不属于任何一个文件系统只存在于内存中
4、有名管道中无数据的时候 读取阻塞
5、有名管道写入的时候FIFO遵循先进先出规则
6、有名管道有名字 在文件系统中可见，可以调用open函数打开管道通过文件描述符进程read write
7、有名管道不支持lseek移动文件指针



信号 signal

(1)信号：唯一的异步通信机制
//同步：事件按照一定的顺序执行
//异步：事件什么时候来不知道

(2)信号的使用
一个进程发生给另一个进程
（3）信号发出者
进程  内核
（4）信号接收者
进程
（5)关于ctr］+ c
摁下ctrl+c 终端识别后内核发出了一个信号给当前正在运行的进程告诉进程立刻停止运行
(6)如何查看系统有哪些信号:
kill -1



#define SIGINT 2
#define SIGQUIT 3
SIGINTrctrl+c//2
SIGQUITctrl+\终止程序//3
SIGILL非法指令
SIGABRT通过abort函数实现程序终止,abort函数为异常终止一个进程
SIGFPE除数为0会产生－-浮点异常
SIGKILL必杀信号//9
SIGSEGV段错误--地址非法使用
SIGPIPE管道破裂
SIGALRM闹钟信号用alarm函数设置闹钟告诉系统时间到当时间到就会发送这个信号／/14
SIGTERM终止信号ki11命令向进程发送这个信号／/15kil16785
SIGCHLD子进程终止或者停止的时候 会向父进程发送此信号//17
SIGCONT让一个暂停的进程继续
SIGSTOP让一个程序暂停
SIGTSTPctrl+z 将前台进程扔到后台 并使该进程处于暂停状态//20



信号的响应方式(重点)
当一个进程收到一个信号以后 会有三种响应这个信号的方式
(1)执行默认操作（缺省操作）／/每一个信号都有自己默认的处理方式
(2)忽略信号//发了跟没发一样当没看见
(3)捕捉信号//去执行另外的一个事情



接收信号

ctrl + z bg 后台 fg 前台

（1）函数原型
void (* signal(int signum, void (* handler)(int)))(int);
函数名字叫什么？?
signal//功能 接收信号 有三种响应方式
函数的参数有哪些？?
//参数列表：离函数名最近的（）里面的就是参数列表（int signum，void（*handler）（int)）
int signum, void (*handler)(int)
函数的返回值类型是什么？?
//返回值：把名字和参数列表挡住 就是返回值
void(*)(int)
//指针类型重定义
typedef int *p-t;//将int* 类型重定义为 p_t
typedef void(*handler_t)(int);//将void(*)(int)类型重定义为handler

handler_t signal(int signum,handler_t handler);
(2)功能：实现对接收到的信号的三种响应方式
(3)参数：
typedef void (*sighandler-t)(int) ;
sighandler_t signal(int signum, sighandler_t handler);

intsignum//接收的信号编号
void（*handler）（int）//函数指针，接收到信号后的响应方式
//调用
//1．忽略响应方式I
signal（SIGINT，SIG_IGN)；//ignoreSIG_IGN忽略信号的方式，响应信号
//2，执行默认操作响应方式
signal（SIGINT，SIG_DFL）；//defauTtSIG_DFL执行默认操作的方式，响应信号

//3．捕捉信号后，去做的那件事，执行fun函数
void fun(int num){}

signa］（SIGINT，fun)；/／捕捉信号方式，响应信号,fun函数，是自定义函数

(4)返回值
返回值是一个函数指针void(*)(int)



ki11（8525,SIGINT);



raise (SIGINT);

头文件及函数原型
#include <sys/types.h>
#include <signal.h>
int raise(int sig);
//调用
raise(SIGINT);//给当前进程自己，发送一个SIGINT信号
raise(SIGQUIT);//给当前进程自己，发送一个SIGQUT信号
(2)功能：
使用raise函数，可以当前进程自己发送任意一个信号
(3)参数说明：
int sig//给当前进程自己发送的信号编号
(4)返回值：
成功：0
失败：-1



larm函数(p88)
（1）函数原型
unsigned int alarm(unsigned int seconds)
(2)功能：能定期产生信号I
称为闹钟函数，它可以在进程中设置一个定时器，当定时器时间到，内核 向进程发送SIGALRM信号信号编号
14
（3）参数：
unsigned int seconds ／/秒数，每隔多久产生一次信号
alarm(1);　//1s之后自动产生一个SIGALRM信号
alarm(4);；//4s之后自动产生一个SIGALRM信号
alarm(10);
sleep(3) ;
alarm(5)

返回值：
成功：如果调用此alarm（)前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。
失败：-1



IGCHLD信号
#define SIGCHLD 17
CHLD--> chil缩写
SIGCHLD信号什么时候产生？？？
当子进程结束的时候，内核会给父进程发送一个SIGCHLD信号，父进程的默认操作是 忽略此信号
子进程的结束，是SIGCHLD信号杀死的吗？？
不是
我们利用SIGCHLD信号可以避免出现僵尸进程





## 共享内存

共享内存：在内核空间提供一块内存区 多个进程可以共享访问 对这块内存进行直接读写 ipcs -m -q -s  ipcrm -m 10086

采用的是映射机制：将内存地址映射到各自进程的物理地址 共享内存是进程间通信机制中效率最高的

注意多进程或者多线程间的互斥和同步

1、任创建共享内存 shmget()
2、映射共享内存 shmat（)
3、对共享内存进行读或者写
4、解除共享内存映射 shmdt（)
5、删除共享内存 shmctl()



(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, int size, int shmflg);
(2)功能：创建一个共享内存
(3)参数：
#define IPC_PRIVATE O
key创建共享内存时的内存key值，如果值为IPC_PRIVATE，表示此共享内存是私有的，
只能在亲缘关系进程之间使用，非O值表示，创建一个指定ID的共享内存
多个进程可以通过同一个key值得到同一共享内存的ID
key值是几不重要，重要的是多进程在创建共享内存的时候，用同一个key值，这样就可以得到同一块共享内存的ID
s证e创建的共享内存的大小，以字节为单位
shmflg 创建共享内存的访问权限0666

//调用参考
//有亲缘关系进程间使用key值用IPC_PRIVATE//#define IPC_PRIVATE 0
int shmid = shmget(IPC_PRIVATE, sizeof(int), 0666) ;
//无亲缘关系进程间使用key值用非O的值,指定一个key值
int shmid = shmget(55555, Sizeof(int)， IPC_CREAT | 0666)

(4)返回值：
成功：是共享内存的id，能唯一识别一块共享内存
失败：-1



映射共享内存
//映射共享内存，就是为丁得到共享内存的首地址
（1）头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
void *shmat（int shmid,const void *shmaddr.int shmflg);
（2）功能：将共享内存映射到进程自己的内存空间，得到首地址
（3）参数：
1)shmid是shmget的返回值
2）shmaddr如果非NULL值，表示将共享内存映射到指定地址，通常写NULL
3)shmf1g通常是0.表示共享内存可读可写，也可以写成SHM_RDONLY只读
调川参考
intshmid=shmget（55555，sizeof（int)，IPC_CREAT|0666)://创建

int *p = shmat(shmid，NULL，O);//映射
(4)返回值：
射到进程的有效地址，通过此地址，可以访问共享内存



读写共享内存
a.向共享内存写入内容
*p=200;
b.将共享内存中的内容直接读取打印
printf("*p is %d\n",*p);
c.将共享内存中的内容拷贝出来再打印
intnum*p;
printf("numn is %d\n",num)



(4)解除共享内存映射

(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
int shmdt(const void *shmaddr);
(2)功能：解除共享内存映射
(3)参数：
shmaddr 共享内存映射后的地址
//调用参考
shmdt(p) ;//解除共享内存映射
(4)返回值:
成功0
失败-1



(5)删除共享内存
(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
(2)功能：删除共享内存或者设置共享属性或者获取共享内存属性
I
(3)参数：
intshmid：要操作的共享内存标识符
int cmd:选择shmctl函数的功能
IPC_STAT(获取对象属性)
structshmid_dss={0}；//s用来保存共享内存属性的结构体
shmctl（shmid，IPC_STAT，&s）；//参数地址传递的方式获取共享内存属性

IPC_SET（设置对象属性)
structshmid_ds s;//里面装上要设置的属性
//修改结构体变量s中存储的内容，即要设置的属性
shmctl(shmid, IPC_SET, &s);
IPC_RMID（删除对象)
buf :指定IPC_STAT/IPC_SET时用以保存/设置属性

//调用参考
shmct1（shmid，IPC_RMID，NULL）；//删除共享内存
(4)返回值：
成功0
失败-1



## 消息队列

消息队列：消息是带有类型的 可以发送和接收多个消息这些消息在内核中一个队列里面缓存着（如果没人取走就一直停留在那里）这就是消息队列

(1)创建消息队列msgget()
(2）发送消息msgsnd(）
(3)接收消息msgrcv()
(4）删除消息队列msgctl()



1、消息是先进先出的当不过滤类型时 先发的消息会被先读取
2、消息可以按类型过滤也可以不过滤
3、消息是一个整体有类型+正文可以是个结构体 结构体可以根据需求自己定义
struct msgbuf{
	long mtype;//消息的类型
	char mtext[100];//消息的正文

}

(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgget(key_t key, int msgflg);
(2)功能：创建消息队列
(3)参数：
key-t key I/和共享内存相关的key值理解相同，通过同一个key来获取同一消息队列的ID
int msgflg-//消息队列的访问权限 0666
//调用参考
int msgid = msgget(IPC_PRIVATE, 0666);//亲缘进程
int msgid = msgget(44444, IPC_CREAT I 0666);//不相关的进程
(4)返回值：
成功：消息队列ID唯一标识这个消息队列
失败：-1



(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
struct msgbuf
3
long mtype;//表示消息的类型
char mtext[100]；．//消息的正文
3:I
(2)功能:
发送消息
(3)参数：
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)

struct msgbuf
long mtype;//表示消息的类型
char mtext[100];//消息的正文
int msqid：消息队列的ID，msgget返回值
const void *msgp:要发送的消息的首地址(存放的位置)
struct msgbuf
long mtype;//表示消息的类型
char mtext[1o0];//消息的正文

size_t msgsz消息正文的字节数
int msgflg 发送方式选项0阻塞（如果消息队列满，再继续发送消息，会阻塞)
IPC_NOWAIT不阻塞

strurt msgbuf a = {2，"he]lo"}；／/消息类型是2，消息正文是"hello"
msgsnd(msgid, &a, sizeof(a) - sizeof(long)，O);
(4)返回值：
成功0
失败-1
(5)实例：
struct msgbuf a = {2, "hello"};
msgsnd(msgid, &a, sizeof(a) - sizeof(long), O)



接收消息
(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include_<sys/msg.h>
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg) ;
(2)功能：接收消息
(3)参数
int msqid:msgget的返回值，消息队列的ID
void *msgp:要接收的消息存放的位置（接收消息的缓存区），发送和接收结构体要对应

struct mtype
long mtype;//表示消息的类型
char mtext[100];//消息的正文

size_t msgsz:消息正文的字节数
long msgtyp 0接收消息队列中第一个消息,不过滤消息
vo接收消息队列中类型值为msgtyp的消息，过滤消息
struct msgbuf b = { 0 };
msgrcv(msgid，&b，sizeof(b)-sizeof(long）,0,0)；//接收消息队列中第一个消息，不过滤
msgrcv(msgid，&b，sizeof(b)-sizeof(long）,3,0);//只接收消息队列中类型为3的消息
msgrcv(msgid，&b，sizeof（b)-sizeof（long）,500,0）;//只接收消息队列中类型为500的消息

7/调用参考
struct msgbuf b = { o };
msgrcv(msgid, &b, sizeof(b)）-sizeof(1ong),15，0);
(4)返回值：
>0接收的消息的长度
>-1出错





(4）删除消息队列
(1)头文件及函数原型
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
//调用
msgct1(msgid, IPC_RMID, NULL) ;
T
(2）功能：
删除消息队列
(3）参数：
int msqid://msgget的返回值，消息队列的ID
int cmd:
IPC_STAT//读取消息队列的属性，并将其保存在buf指向的缓存区中

IPC_SET//设置消息队列的属性，这个值取自buf参数
IPC_RMID//从系统中删除消息队列。
structmsqid_ds*buf：//设置或者获取属性使用第三个参数
//调用参考
msgctl(msgid, IPC_RMID, NULL) ;
（4）返回值：
成功:0
失败:1





亲缘关系共享内存

```c
#include "../IO.h"
#include "../PROCESS.h"

int main(int argc, const char *argv[])
{
	int shmid = shmget(IPC_PRIVATE, sizeof(int), 0666);
	if (shmid == -1) { exit(-1); }

	pid_t ret = fork();

	if (ret == -1) {
		exit(-1);
	}
	
	if (ret == 0) {
		int *p = shmat(shmid, NULL, 0);
		if (!p) { exit(-1); }

		*p = 100;
		shmdt(p);
	}

	if (ret > 0) {
		wait(NULL);
		int *p = shmat(shmid, NULL, 0);
		if (!p) { exit(-1); }

		printf("%d\n", *p);
		shmdt(p);

		shmctl(shmid, IPC_RMID, NULL);
	}

	return 0;
}
```



非亲缘关系共享内存

```c
#include "../IO.h"
#include "../PROCESS.h"

int main(int argc, const char *argv[])
{
	int shmid = shmget(10086, sizeof(int) * 10, IPC_CREAT | 0666);
	if (shmid == -1) { exit(-1); }

	int *p = shmat(shmid, NULL, 0);
	if (!p) { exit(-1); }
	
	int i = 0;
	for (i; i < 10; ++i) {
		printf("%d ", p[i]);
	}

	shmdt(p);

	shmctl(shmid, IPC_RMID, NULL);
	return 0;
}


#include "../IO.h"
#include "../PROCESS.h"

int main(int argc, const char *argv[])
{
	int shmid = shmget(10086, sizeof(char) * 128, IPC_CREAT | 0666);
	if (shmid == -1) { exit(-1); }

	int *p = shmat(shmid, NULL, 0);
	if (!p) { exit(-1); }

	printf("please input: ");

	int i = 0;
	for (i; i < 10; ++i) {
		scanf("%d", &p[i]);
	}

	shmdt(p);

	return 0;
}
```





消息队列

```c
#include "../IO.h"
#include "../PROCESS.h"

struct msg {
	long lc;
	char straight[128];
};

int main(int argc, const char *argv[]){

	struct msg msg = {0};

	int msgid = msgget(10086, IPC_CREAT | 0666);
	if (msgid == -1) { exit(-1); }

	while (1) {
		printf("please input lc and straight: ");
		scanf("%ld %s", &msg.lc, msg.straight);

		if (msg.lc == -1) {
			break;
		}
		msgsnd(msgid, &msg, sizeof(msg) - sizeof(long), 0);
	}
	
	return 0;
}

#include "../IO.h"
#include "../PROCESS.h"

struct msg {
	long lc;
	char straight[128];
};

int main(int argc, const char *argv[]){

	struct msg msg = {0};

	int msgid = msgget(10086, IPC_CREAT | 0666);
	if (msgid == -1) { exit(-1); }

	msgrcv(msgid, &msg, sizeof(msg) - sizeof(long), 0, 0);

	printf("lc : %ld straight : %s\n", msg.lc, msg.straight);
	
	return 0;
}
```



```c
#include "../IO.h"
#include "../PROCESS.h"

struct msg {
	long lc;
	char straight[128];
};

void *snd(void *p){

	int msgid = msgget(10086, IPC_CREAT | 0666);
	if (msgid == -1) { exit(-1); }

	int *msg_lc = p;

	struct msg msg = {0};
	msg.lc = msg_lc[0];

	while (1) {
		printf("please input straight: ");
		scanf("%s", msg.straight);
		msgsnd(msgid, &msg, sizeof(struct msg) - sizeof(long), 0);
	}
}

void *rcv(void *p){

	int msgid = msgget(10086, IPC_CREAT | 0666);
	if (msgid == -1) { exit(-1); }

	int *msg_lc = p;

	struct msg msg = {0};
	msg.lc = msg_lc[1];

	while (1) {

		msgrcv(msgid, &msg, sizeof(struct msg) - sizeof(long), msg.lc, 0);
		printf("%s\n", msg.straight);
	}
}

int main(int argc, const char *argv[]){

	if (argc != 3) { exit(-1); }

	int msgArr[2] = {atoi(argv[1]), atoi(argv[2])};

	pthread_t id1 = 0, id2 = 0;

	int ret1 = pthread_create(&id1, NULL, snd, msgArr);
	int ret2 = pthread_create(&id2, NULL, rcv, msgArr);

	if (ret1 == -1 || ret2 == -1) { exit(-1); }

	pthread_join(id1,NULL);
	pthread_join(id2,NULL);

	return 0;
}

```





# 网络编程

地址格式转换
点分十进制IP转整型IP
#include <sys/socket.h>
#include <netinet/in.h>
typedef unsignedjint in_addr_t;
in_addr_t inet_addr(const char *cp);//
//调用
in_addr_t addr = inet_addr("192.168.0.11");
printf（"整型IP地址是%x\n",addr）；//%x以十六进制的格式输出
(1)功能：
将点分制的ip地址转成整型ip地址
(2)参数：
constchar*cp//保存的是"192.168.011”字符串的首地址，被转换的点分IP地址
(3)返回值：
返回值就是整型的IP地址



整型IP转点分十进制字符串IP
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
char *inet_ntoa(struct in_addr in);
(1)功能：
将整型的IP地址转换成点分格式的IP地址）
(2）参数：
structin_addrin//整型的IP地址
struct in_addr
in_addr_t s_addr;
J;//typedef unsigned int in_addr_t;
(3)返回值：
char*点分形式IP地址字符串的首地址"192.168.0.11"



1.3.端口号
功能：区分不同的网络应用-掌握
端口号unsignedshort占2个字节0---65535
端口号：是用来识别应用程序的，如果A程序绑定55555端口号，那么网络里面来了一包数
据，就发给A程序
端口号是一种资源，用unsignedshort来保存，（0-65535）有些应用的端口号是固定的
ftp21IFile Transfer Protocol
http80HyperText Transfer Protocol)
DNS53Domain Name System
DHCP67Dynamic Host Configuration Protocol
我们写的应用程序尽量用>1024的端口号



2.字节序
字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序
1）主机字节序（HostByteOrder）：主机字节序是指特定主机体系结构所采用的字节序。不同的计算机体系结构可能采用不同的字节序
2）网络字节序（Network ByteOrder）：网络字节序是一种标准化的字节序在网络通信中，为了保证不同主机之间数据的正确传输和解析，通常会采用统一的
网络字节序。
通常会将数据在发送前转换为网络字节序
目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian和Little-Endian



概念
小端模式（主机字节序）：低地址存储低位高地址存储高位
buf=0x12 34 56 78;
buf[3] 0x12高位高地址
buf[2] 0x34
buf[1] 0x56
buf[0] 0x78低位低地址
大端模式（网络字节序)：低地址存储高位 高地址存储低位网络字节序是大端模式
buf=0x12 34 56 78;
buf[3] 0x78低位高地址
buf[2] 0x56
buf[1] 0x34
buf[0] 0x12高位低地址
1）网络字节序：低地址存高位高地址存地位
2）主机字节序：低地址存低位高址存高位



nc -u 192.168.31.153 65536

```c
#ifndef _SCOKET_H
#define _SCOKET_H

#include <stdio.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>     
#include <sys/socket.h>

#endif
```

```c
#ifndef _IO_H
#define _IO_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>

#endif
```

```c
#ifndef _PROCESS_H
#define _PROCESS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <signal.h>//信号
#include <pthread.h> // process thread 进程线程
#include <semaphore.h> //semaphore 信号量
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#endif
```



```c
#include "../socket.h"

int main(int argc, const char *argv[])
{
	int socketId = socket(AF_INET, SOCK_DGRAM, 0);
	if (-1 == socketId) {

		exit(-1);
	}

	struct sockaddr_in selfAddr = {
		AF_INET, // sin_family
		htons(65535), // sin_port
		//inet_addr("192.168.31.155") // sin_addr.a_addr  // ip change
        INADDR_ANY
	};

	int ret = bind(socketId, (const struct sockaddr *)&selfAddr, sizeof(selfAddr));
	if (-1 == ret) {
		exit(-1);
	}

	char buf[128] = {0};
	struct sockaddr_in sndAddr = {0};
	socklen_t len = sizeof(sndAddr);
	ssize_t retRecv = recvfrom(socketId, buf, sizeof(buf), 0, (struct sockaddr *)&sndAddr, &len);
	if (-1 == retRecv) {
		exit(-1);
	}


	printf("%s\n", buf);
	close(socketId);

	return 0;
}
```

```c
#include "../socket.h"

int main(int argc, const char *argv[])
{
	int socketId = socket(AF_INET, SOCK_DGRAM, 0);
	if (-1 == socketId) {
		exit(-1);
	}

	struct sockaddr_in recvAddr = {
		AF_INET, // sin_family
		htons(65535), // sin_port
		inet_addr("192.168.31.155") // sin_addr.a_addr
	};

	char buf[128] = "hello world!";

	ssize_t retSend = sendto(socketId, buf, sizeof(buf), 0, (struct sockaddr *)&recvAddr, sizeof(recvAddr));
	if (-1 == retSend) {
		exit(-1);
	}

	close(socketId);

	return 0;
}
```



三次握手



```c
#include "../socket.h"

int main(int argc, const char *argv[])
{
	int socketId = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == socketId) {
		exit(-1);
	}

	struct sockaddr_in selfAddr = {
		AF_INET, // sin_family
		htons(65535), // sin_port
		inet_addr("192.168.31.155") // sin_addr.a_addr
	};

	int ret = bind(socketId, (const struct sockaddr *)&selfAddr, sizeof(selfAddr));
	if (-1 == ret) {
		exit(-1);
	}

	int retListen = listen(socketId, 10);	
	if (-1 == retListen) {
		exit(-1);
	}

	int newConnectID = accept(socketId, NULL, NULL);
	if (-1 == newConnectID) { exit(-1); }

	char buf[128] = {0};
	ssize_t retRead = read(newConnectID, buf, sizeof(buf));
	if (-1 == retRead) { exit(-1); }
	
	puts(buf);

	close(newConnectID);
	close(socketId);

	return 0;
}

```

```c
#include "../socket.h"

int main(int argc, const char *argv[])
{
	int socketId = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == socketId) {
		exit(-1);
	}

	struct sockaddr_in serverAddr = {
		AF_INET, // sin_family
		htons(65535), // sin_port
		inet_addr("192.168.31.155") // sin_addr.a_addr
	};

	int ret = connect(socketId, (const struct sockaddr *)&serverAddr, sizeof(serverAddr));
	if (-1 == ret) {
		exit(-1);
	}

	char buf[128] = "hello world!";
	ssize_t retWrite = write(socketId, buf, sizeof(buf));
	if (-1 == retWrite) { exit(-1); }

	close(socketId);

	return 0;
}

```





全局错误处理器

- 在客户端，将 `person_t` 结构体的数据序列化为文本格式，然后发送。
- 在服务端，接收文本数据，并将其反序列化为 `person_t` 结构体。



多进程并发服务器

```c
#include "../socket.h"

void msgBack(int accId){
	while (1) {
		char buf[128] = {0};
		int len = recv(accId, buf, sizeof(buf) - 1, 0);
		buf[len] = 0;
		send(accId, buf, len, 0);
	}
}

int main(int argc, const char *argv[])
{
	int sockId = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == sockId) { exit(-1); }

	int on = 1;
	int sockopt = setsockopt(sockId, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
	if (-1 == sockopt) { exit(-1); }

	struct sockaddr_in s = {
		AF_INET,
		htons(65535),
		INADDR_ANY		
	};
	int bindId = bind(sockId, (const struct sockaddr *)&s, sizeof(s));
	if (-1 == bindId) { exit(-1); }

	int listenId = listen(sockId, 10);
	if (-1 == listenId) { exit(-1); }
	
	while (1) {
		int accId = accept(sockId, NULL, NULL);

		int id = fork();
		if (-1 == id) { exit(-1); }

		if (0 == id) {
			msgBack(accId);
		}


	}
	return 0;
}
```



多线程并发服务器

```c
#include "../socket.h"

void msgBack(void *acc){
	pthread_detach(pthread_self());

	int accId = *(int *)acc;

	while (1) {
		char buf[128] = {0};
		int len = recv(accId, buf, sizeof(buf) - 1, 0);
		buf[len] = 0;
		send(accId, buf, len, 0);
	}
}

int main(int argc, const char *argv[])
{
	int sockId = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == sockId) { exit(-1); }

	int on = 1;
	int sockopt = setsockopt(sockId, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
	if (-1 == sockopt) { exit(-1); }

	struct sockaddr_in s = {
		AF_INET,
		htons(65535),
		INADDR_ANY		
	};
	int bindId = bind(sockId, (const struct sockaddr *)&s, sizeof(s));
	if (-1 == bindId) { exit(-1); }

	int listenId = listen(sockId, 10);
	if (-1 == listenId) { exit(-1); }
	
	while (1) {
		int accId = accept(sockId, NULL, NULL);

		int tid = 0;
		pthread_create(&tid, NULL, msgBack, &accId);


	}
	return 0;
}
```





192.168.1.21

128 64 32 16 8 4 2 1

128 192 224 240 248 252 254 255

1100 0000  1010 0000  0000 0001  0001 0101





# sql

CREATE TABLE db_01(int id, ft float, str varchar(20));

CREATE TABLE IF NOT EXISTS db_01(int id, ft float, str varchar(20));

INSERT INTO db_01 VALUES(1, 1.1, 'XIOAYU');

SELECT * FROM db_01;

INSERT INTO db_01(int, str) VALUES(4, 'XIAOYU');



CREATE TABLE IF NOT EXISTS db_02(id integer PRIMARY KEY AUTOINCREMENT, ft float, str varchar(20));

INSERT INTO db_02(ft, str) VALUES(1.1, 'XIAOYU');



```c
#include "../m.h"

void res_cc(sqlite3 *db, int line, const char *msg) {
	fprintf(stderr, "%d: %s\n", line, msg);
	sqlite3_close(db);
	exit(-1);
}

int main(int argc, const char *argv[]) {
	sqlite3 *db = NULL;
	if (sqlite3_open("./database.db", &db)) { res_cc(db, __LINE__, sqlite3_errmsg(db)); }

	const char *sql = "CREATE TABLE IF NOT EXISTS \
					   table_01(id integer PRIMARY KEY AUTOINCREMENT, \
					   username varchar(16), password varchar(64), status BOOLEAN NOT NULL DEFAULT 1)";
	char *errmsg = NULL;

	if (sqlite3_exec(db, sql, NULL, NULL, &errmsg)) {res_cc(db, __LINE__, errmsg); }

	// sql = "INSERT INTO table_01 VALUES(200, 'XIAOYU', '000000', 1)";

	sql = "INSERT INTO table_01(username, password, status) VALUES('XIAOYU', '000000', 1)";
	if (sqlite3_exec(db, sql, NULL, NULL, NULL)) { res_cc(db, __LINE__, sqlite3_errmsg(db)); }

	char **result = NULL;
	int row = 0, col = 0;
	
    sql = "SELECT * FROM table_01";	
	if (sqlite3_get_table(db, sql, &result, &row, &col, NULL)) { res_cc(db, __LINE__, sqlite3_errmsg(db)); }

	if (!row) { fprintf(stdout, "data null!\n"); }
	else {
		int i = 0;
		for (i; i < (row + 1) * col; ++i) {
			fprintf(stdout, "%s\t", result[i]);

			if (!((i + 1) % 4)) {
				fprintf(stdout, "\n");
			}
		}

	}

	sqlite3_free_table(result);

	sqlite3_close(db);

	return 0;
}
```



nautilus . 打开文件夹



cmake_minimum_required(VERSION 3.28)
project(1218)

set(CMAKE_CXX_STANDARD 11)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../bin)

set(SOURCES main.cpp)

add_executable(1218 ${SOURCES})









linux 虚拟机安装

1. 拖拽

sudo apt-get autoremove open-vm-tools
sudoapt-get install open-vm-tools
sudo apt-get install open-vm-tools-desktop





sudo apt-get install gcc

sudo apt-get install g++



字体



`Ctrl + Alt + T` 快捷键打开「终端」

fc-list 显示 Ubuntu 系统中所有已安装的字体列表

cd /usr/share/fonts
#or
sudo mkdir /usr/share/fonts

打开「终端」并导航到 `/usr/share/fonts` 目录，如果没有，就创建一个



sudo cp ~/Downloads/*.ttf /usr/share/fonts 将下载好的字体文件（ttf、otf 等）复制到新创建的 fonts 目录中

sudo fc-cache -f -v 运行以下命令更新字体缓存，让系统识别新安装的字体





美化

sudo apt install chrome-gnome-shell gnome-shell-extension-prefs gnome-tweaks







sudo apt-get install chrome-gnome-shell

https://wiki.gnome.org



1. git clone https://github.com/vinceliuice/colloid-gtk-theme.git
2. cd colloid-gtk-theme
3. sudo apt-get install dos2unix 将脚本的行结束符从 Windows 风格转换为 Linux 风格 dos2unix install.sh
4. https://www.pling.com/p/1648124
5. pamac build chrome-gnome-shell
6. App Grid / Big Sur Status Area / Blur my Shell-GNU / Coverfloww Alt-Tab / Floating Dock-GNU / Just Perfection-GNU / Logo Menu-GNO / Media Controls / Unite-GNOME / User Themes
7. 

sudo apt-get install gnome-shell-extension-prefs




# 代码规范

## 1. 标识符命名规范

标识符的命名力求做到统一、达意和简洁

- 统一 统一是指对于同一个概念 在程序中用同一种表示方法 比如对于供应商既可以用 supplier 也可以用 provider 但是我们只能选定一个使用 至少在一个项目中保持统一 如果对同一概念有不同的表示方法 会使代码混乱难以理解
- 达意 达意是指标识符能准确的表达出它所代表的意义
- 简洁 简洁是指在统一和达意的前提下用尽量少的标识符 如果不能达意宁愿不要简洁

## 2. 标识符命名方式

- 匈牙利命名法 匈牙利命名法是早期的规范由微软的一个匈牙利人发明的 该命名规范要求前缀字母用变量类型的缩写其余部分用变量的英文或英文的缩写单词第一个字母大写
- 驼峰式命名法  camelCase 又叫小驼峰式命名法 该命名规范 要求第一个单词首字母小写后面其他单词首字母大写简单粗暴易学易用 变量 方法
- 帕斯卡命名法  PascalCase 又叫大驼峰式命名法每个单词的第一个字母都要大写 类
- 下划线命名法  snake_case下划线命名法并不那么备受推崇 通过下划线来分割全部都是大写的单词 该命名规范也是很简单要求单词与单词之间通过下划线连接即可
- 大写蛇形命名法 SNAKE_CASE 通过下划线来分割全部都是大写的单词 该命名规范也是很简单要求单词与单词之间通过下划线连接即可 在宏定义和常量中使用比较多
- 连字符命名法 kebab-case 前端 每个单词之间使用连字符 - 连接

## 3. 包名命名方式

### 3.1 基于域名反向的命名方式

1. **定义**：这种方式使用公司的域名反向作为包名的前缀，以确保全局唯一性。
2. 优点
   - 唯一性：由于域名是唯一的，因此基于域名的包名也具有唯一性。
   - 组织性：域名反向的命名方式有助于按照公司或组织的结构来组织代码。
3. **示例**：如果公司的域名为“example.com”，则包名可能是“com.example.project”。

### 二、使用小写字母和点分隔符

1. **定义**：包名应全部使用小写字母，并使用点（.）作为分隔符来分隔不同的层级或模块。

2. 优点

   ：

   - 一致性：小写字母和点分隔符的命名方式有助于保持命名的一致性。
   - 可读性：清晰的层级结构使得包名更易于阅读和理解。

3. **示例**：`com.example.util`、`com.example.model`等。

### 三、避免使用特殊字符和保留关键字

1. **定义**：包名中不应包含特殊字符（如空格、连字符等）和Java或特定平台（如Android）的保留关键字。

2. 优点

   ：

   - 避免冲突：不使用特殊字符和保留关键字可以避免命名冲突和编译错误。
   - 提高可移植性：遵循这一规则有助于确保代码在不同平台上的可移植性。

### 四、有意义的命名

1. **定义**：包名应具有描述性，能够清晰地表达包的内容或用途。

2. 优点

   ：

   - 易于理解：有意义的命名有助于开发人员快速理解包的内容和用途。
   - 提高代码质量：清晰的命名有助于提高代码的可读性和可维护性。

3. **示例**：`com.example.payment`表示与支付相关的代码包，`com.example.database`表示与数据库相关的代码包。

### 五、遵循项目或组织的命名规范

1. **定义**：在某些项目或组织中，可能会有特定的命名规范或约定。

2. 优点

   ：

   - 一致性：遵循项目或组织的命名规范有助于保持代码命名的一致性。
   - 团队协作：清晰的命名规范有助于团队成员之间的协作和交流。

## 4. 后缀

Service 表明这个类是个服务类，里面包含了给其他类提同业务服务的方法  PaymentOrderService

Impl   这个类是一个实现类，而不是接口 PaymentOrderServiceImpl

Inter  这个类是一个接口   LifeCycleInter

Dao 这个类封装了数据访问方法   PaymentOrderDao

Action  直接处理页面请求，管理页面逻辑了类  UpdateOrderListAction

Listener   响应某种事件的类   PaymentSuccessListener

Event  这个类代表了某种事件  PaymentSuccessEvent

Servlet 一个Servlet  PaymentCallbackServlet

Factory 生成某种对象工厂的类  PaymentOrderFactory

Adapter 用来连接某种以前不被支持的对象的类  DatabaseLogAdapter

Job 某种按时间运行的任务  PaymentOrderCancelJob

Wrapper 这是一个包装类，为了给某个类提供没有的能力  SelectableOrderListWrapper

Bean   这是一个POJO   MenuStateBean

1.4 方法名

首字母小写，如 addOrder() 不要 AddOrder()

动词在前，如 addOrder()，不要orderAdd()

动词前缀往往表达特定的含义，如下表：

前缀名 意义  举例

create  创建  createOrder()

delete  删除  deleteOrder()

add 创建，暗示新创建的对象属于某个集合  addPaidOrder()

remove  删除  removeOrder()

init或则initialize   初始化，暗示会做些诸如获取资源等特殊动作   initializeObjectPool

destroy 销毁，暗示会做些诸如释放资源的特殊动作 destroyObjectPool

open   打开  openConnection()

close  关闭  closeConnection()<

read   读取  readUserName()

write  写入  writeUserName()

get 获得  getName()

set 设置  setName()

prepare 准备  prepareOrderList()

copy   复制  copyCustomerList()

modity  修改  modifyActualTotalAmount()

calculate  数值计算   calculateCommission()

do  执行某个过程或流程  doOrderCancelJob()

dispatch   判断程序流程转向   dispatchUserRequest()

start  开始  startOrderProcessing()

stop   结束  stopOrderProcessing()

send   发送某个消息或事件  sendOrderPaidMessage()

receive 接受消息或时间 receiveOrderPaidMessgae()

respond 响应用户动作  responseOrderListItemClicked()

find   查找对象   findNewSupplier()

update  更新对象   updateCommission()

find方法在业务层尽量表达业务含义，比如 findUnsettledOrders()，查询未结算订单，而不要findOrdersByStatus()。 数据访问层，find,update等方法可以表达要执行的sql，比如findByStatusAndSupplierIdOrderByName(Status.PAID, 345)







2.2 行宽

行宽度不要超过80。Eclipse标准

2.3 包的导入

删除不用的导入，尽量不要使用整个包的导入。在eclipse下经常使用快捷键 ctrl+shift+o 修正导入。







2.6.3 空行的使用

空行可以表达代码在语义上的分割，注释的作用范围，等等。将类似操作，或一组操作放在一起不用空行隔开，而用空行隔开不同组的代码， 如下：

order = orderDao.findOrderById(id);

 

//update properties

order.setUserName(userName);

order.setPrice(456);

order.setStatus(PAID);

orderService.updateTotalAmount(order);

session.saveOrUpdate(order);

上例中的空行，使注释的作用域很明显.

•  连续两行的空行代表更大的语义分割。

•  方法之间用空行分割

•  域之间用空行分割

•  超过十行的代码如果还不用空行分割，就会增加阅读困难



\3. 注释规范

3.1 注释 vs 代码

•  注释宜少而精，不宜多而滥，更不能误导

•  命名达意，结构清晰， 类和方法等责任明确，往往不需要，或者只需要很少注释，就可以让人读懂；相反，代码混乱，再多的注释都不能弥补。所以，应当先在代码本身下功夫。

•  不能正确表达代码意义的注释，只会损害代码的可读性。

•  过于详细的注释，对显而易见的代码添加的注释，罗嗦的注释，还不如不写。

•  注释要和代码同步，过多的注释会成为开发的负担

•  注释不是用来管理代码版本的，如果有代码不要了，直接删除，svn会有记录的，不要注释掉，否则以后没人知道那段注释掉的代码该不该删除。



3.2 Java Doc

表明类、域和方法等的意义和用法等的注释，要以javadoc的方式来写。Java Doc是给类的使用者来看的，主要介绍 是什么，怎么用等信息。凡是类的使用者需要知道，都要用Java Doc 来写。非Java Doc的注释，往往是个代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等。 如下：

/**

\* This is a class comment

*/

public class TestClass {

  /**

  \* This is a field comment

  */

  public String name;

  /**

  \* This is a method comment

  */

  public void call() {

  }

}

3.3 块级别注释

3.3.1 块级别注释，单行时用 //, 多行时用 /* .. */。

3.3.2 较短的代码块用空行表示注释作用域

3.3.3 较长的代码块要用

/* ------ start: ------ */

和

/* -------- end: ------- */

包围

如：

/* ----------start: 订单处理 ------- */

//取得dao

OrderDao dao = Factory.getDao("OrderDao");

/* 查询订单 */

Order order = dao.findById(456);

//更新订单

order.setUserName("uu");

order.setPassword("pass");

order.setPrice("ddd");

orderDao.save(order);

/*----------end: 订单处理 ------- */

3.3.4 可以考虑使用大括号来表示注释范围

使用大括号表示注释作用范围的例子：

/*----------订单处理 ------- */

{

 //取得dao

 OrderDao dao = Factory.getDao("OrderDao");

 /* 查询订单 */

 Order order = dao.findById(456);

 

 //更新订单

 order.setUserName("uu");

 order.setPassword("pass");

 order.setPrice("ddd");

 

 orderDao.save(order);

}

3.4 行内注释

行内注释用 // 写在行尾

4 最佳实践和禁忌

4.1 每次保存的时候，都让你的代码是最美的

程序员都是懒惰的，不要想着等我完成了功能，再来优化代码的格式和结构，等真的把功能完成，很少有人会再愿意回头调整代码。

4.2 使用log而不是System.out.println()

log可以设定级别，可以控制输出到哪里，容易区分是在代码的什么地方打印的，而System.out.print则不行。而且，System.out.print的速度很慢。所以，除非是有意的，否则，都要用log。至少在提交到svn之前把System.out.print换成log。

4.3 每个if while for等语句，都不要省略大括号{}

看下面的代码：

if (a > b)

  a++;

如果在以后维护的时候，需要在a > b 时，把b++，一步小心就会写成：

if (a > b)

  a++;

  b++;

这样就错了，因为无论a和b是什么关系，b++都会执行。 如果一开始就这样写：

if (a > b)  {

  a++;

}

相信没有哪个笨蛋会把b++添加错的。而且，这个大括号使作用范围更明显，尤其是后面那行很长要折行时。

4.4 善用TODO:

在代码中加入 //TODO: ，大部分的ide都会帮你提示，让你知道你还有什么事没有做。比如：

if (order.isPaid()) {

  //TODO: 更新订单

}

4.5 在需要留空的地方放一个空语句或注释，告述读者，你是故意的

比如：

if (!exists(order)) {

  ;

}

或：

if (!exists(order)) {

  //nothing to do

}

4.6 不要再对boolean值做true false判断

比如：

if (order.isPaid() == true) {

  // Do something here

}

不如写成：

if (order.isPaid()) {

  //Do something here

}

后者读起来就很是 if order is paid, …. 要比 if order’s isPaid method returns true, … 更容易理解

4.7 减少代码嵌套层次

代码嵌套层次达3层以上时，一般人理解起来都会困难。下面的代码是一个简单的例子：

public void demo(int a, int b, int c) {

  if (a > b) {

​    if (b > c) {

​      doJobA();

​    } else if (b < c) {

​      doJobB()

​    }

  } else {

​    if (b > c) {

​      if (a < c) {

​        doJobC();

​      }

​    }

  }

}

减少嵌套的方法有很多：

•  合并条件

•  利用 return 以省略后面的else

•  利用子方法

比如上例，合并条件后成为：

public void demo(int a, int b, int c) {

  if (a > b && b > c) {

​    doJobA();

  }

  if (a > b && c > b) {

​    doJobB();

  }

  if (a <= b && c < b && a < c) {

​    doJobC();

  }

}

如果利用return 则成为：

public void demo(int a, int b, int c) {

  if (a > b) {

​    if (b > c) {

​      doJobA();

​      return;

​    }

​    doJobB()

​    return;

  }

 

  if (b > c) {

​    if (a < c) {

​      doJobC();

​    }

  }

}

利用子方法，就是将嵌套的程序提取出来放到另外的方法里。

4.8 程序职责单一

关注点分离是软件开发的真理。人类自所以能够完成复杂的工作，就是因为人类能够将工作分解到较小级别的任务上，在做每个任务时关注更少的东西。让程序单元的职责单一，可以使你在编写这段程序时关注更少的东西，从而降低难度，减少出错。

4.9 变量的声明，初始化和被使用尽量放到一起

比方说如下代码：

int orderNum= getOrderNum();

//do something withou orderNum here

call(orderNum);

上例中的注释处代表了一段和orderNum不相关的代码。orderNum的声明和初始化离被使用的地方相隔了很多行的代码，这样做不好，不如这样：

//do something withou orderNum here

int orderNum= getOrderNum();

call(orderNum);

4.10 缩小变量的作用域

能用局部变量的，不要使用实例变量，能用实例变量的，不要使用类变量。变量的生存期越短，以为着它被误用的机会越小，同一时刻程序员要关注的变量的状态越少。实例变量和类变量默认都不是线程安全的，局部变量是线程安全的。比如如下代码：

public class OrderPayAction{

  private Order order;

 

  public void doAction() {

​    order = orderDao.findOrder();

​    doJob1();

​    doJob2();

  }

 

  private void doJob1() {

​    doSomething(order);

  }

 

  private void doJob2() {

​    doOtherThing(order);

  }

}

上例中order只不过担当了在方法间传递参数之用，用下面的方法更好：

public class OrderPayAction{

  public void doAction() {

​    order = orderDao.findOrder();

​    doJob1(order);

​    doJob2(order);

  }

 

  private void doJob1(Order order) {

​    doSomething(order);

  }

 

  private void doJob2(Order order) {

​    doOtherThing(order);

  }

}

4.11 尽量不要用参数来带回方法运算结果

比如：

public void calculate(Order order) {

  int result = 0;

  //do lots of computing and store it in the result

  order.setResult(result);

}

 

public void action() {

  order = orderDao.findOrder();

  calculate(order);

  // do lots of things about order

}

例子中calculate方法通过传入的order对象来存储结果， 不如如下写：

public int calculate(Order order) {

  int result = 0;

  //do lots of computing and store it in the result

  return result;

}

public void action() {

  order = orderDao.findOrder();

  order.setResult(calculate(order));

  // do lots of things about order

}

4.12   除非有相当充足的理由，否则不许使用省略泛型类的类型参数









忘了具体实现就说运行过程





